법선 매핑
높이맵: 높은곳은 흰색, 낮은곳은 검은색
법선맵: 법선벡터를 색상으로 저장(조명 표현), 울퉁불퉁한 사실적인 표현이가능
변위맵: 픽셀마다의 높이차이를 이미지로 저장 ( 굴곡표현)
이러한 범프매핑의 특징은 로우폴리곤으로 하이폴리곤의 효과를 낼 수 있는것
법선맵의 색상정보는 법선벡터 xyz를 의미함
x축 T축 y B z N축 축이라함 (텍스처 좌표계)
법선벡터가 노말라이즈됬다고 할때 -1~1값을갖음 그러나 색상은 0~1값을 갖는다 따라서 변환이필요하다
보통 법선맵을 사용하는게 목적이니까 색상을 법선벡터로 바꾸는법을 알고있으면된다.
법선맵은 법선벡터는 텍스처좌표계라서 모델좌표계로 변환해야 제대로 적용이된다.
보통 T B N 중 두개가 주어지기 때문에 외적을 통해서 나머지하나를 구하고 법선 벡터에
TBN행렬을 곱하여 모델 좌표계로 바꿔쓴다.
법선맵은 대부분 수직을 향하기 때문에 z 파란빛을 띈다
변위 매핑
보통 법선맵의 알파채널을 사용 (0,1)
기하셰이더 또는 테셀레이션 단계에서 사용
변위 맵 생성 도구로 생성
시차 매핑
시점 변화에 따른 객체의 변이 나타내고, 시점에 따라 표면이 다르게 보이게하는 매핑
법선 맵만 사용하면 표면이 정면과 측면에서 볼때 같다.
따라서 카메라 위치에 따라 텍스처 좌표 교정이 필요하다.
텍스처 좌표, 표면의 높이, 픽셀에서 카메라까지의 벡터를 이용하여 보정된 텍스쳐 좌표를 구할수 있다.
계산 쉐이더
그래픽 파이프라인은 자료구조를 데이터로 출력하는 반면에 계산 쉐이더는 자료구조를 처리한다.
GPU의 병령 프로세서를 사용한다.
쓰레드는 계산쉐이더의 기본처리 단위이며 쓰레드들은 쓰레드 그룹으로 분할됨
메모리공유와 쓰레드 동기화를 제공, 공유메모리 동기화는 중복연산 해결을 위해 사용한다
8개의 UAV를 쉐이더에 연결 가능
일반적으로 텍스처를 처리하여 화면으로 출력하기위해 사용한다
사용 예시로는 컨벌루젼 매스크를 이용한 블러링이나, 솜벨매스크를 이용한 경계찾기가 있다.
기하쉐이더 단계
하나의 완전한 프리미티브를 구성하는 정점들을 바당서 새로운 정점 생성후 출력함
간단한 프리미티브를 더복잡한 프리미티브로 바꿈
각 프리미티브에 대해 한번씩 호출, Point Line stream 사용가능하고 이 stream에 새로운 정점들을 추가한다
출력 프리미티브 개수는 자유롭게 설정, 모든 출력은 스트립의 형태임
SO 출력시 버퍼에만 넘어가기때문에 렌더타겟에는 변화가 일어나지 않을수 있다.
적은 수의 정점으로부터 정점을 추가하여 더많은 폴리곤들을 쉐이더에서 만들 수 있다.
스트림 출력단계
기하쉐이더의 정점 데이터를 메모리 버퍼로 GPU를 사용해 출력하는게 핵심이고, 이 때 출력된 버퍼는
렌더링 파이프라인에서 다시사용이 가능하다. 
출력 버퍼는 총4개로 동시에 4개까지 연결이가능하나 주로 하나만 사용한다.
기하쉐이더의 출력이 스트림 버퍼로 전달되도록 하하려면 픽셀쉐이더, 깊이 스텐실 버퍼, 레스터라이저를 비활성화해야한다
스트림 출력으로 출력한 내용을 입력조립기에서 다시 사용하려면 읽고 쓰는 작업이 필요한데
따라서 디폴트힙, 디폴트 힙내용을 리드백 힙으로 카피해서 읽고, 업로드힙에 쓰고 디폴트 힙으로 카피하여 사용하므로
총3종류의 힙이 필요하다.
스트림 출력을 위한 파이프라인과 레스터라이저로 출력하는 파이프 라인 2개를 번갈아 사용하여 파티클을 구현할 수도 있다.
헐쉐이더 단계
입력 패치마다 한번씩 호출
패치를 구성하는 점을 제어점이라함
출력 제어점으로 변환하는 것과 패치 상수들을 만드는 단계로 구성
제어점 단계는 입력제어점에대해 한번 실행하여 출력제어점을 생성하고
패치 상수 단계는 패치마다 한번실행되며, 패치는 1~32개의 제어점을 가질수있다. 또한 테셀레이션 인자를 결정한다.
테셀리이터 단계
고정 파이프라인 단계,헐쉐이더 연결시 자동적으로 초기화됨
하나의 도메인을 여러개의 삼각형 점등으로 분할하는게 목적
정규화된 좌표계사용 0~1
도메인 쉐이더
출력제어점과 쪼개진 u,v좌표를 이용해 프리미티브를 생성
RS가 요구하는 정점들을 출력함
테셀레이터가 생성한 각 정점에 대해 한번씩 실행하며, 변환을 처리한다.
멀티 스레딩
CPU와 GPU가 노는 시간이 많은것을 줄이기 위한 방법이다.
보통 단일스레드(주스레드)로 프로세스를 실행하나, 추가적인 스레드를 생성하여 모든 CPU가 일하게 할 수 있다.
여러 스레드가 공유자원에 접근하는 경우 데드락이 발생할 수있는데 이를 위해 동기화 객체가 존재하고
주로 mutex나 Event를 이용한다.
멀티스레드를 렌더링에 이용하는 방법은 커다란 씬을 여러개로 분할하고 병렬적으로 처리하는 것이다.
이 때 주의할점은 명령리스트와 명령 할당자는 스레드 안전하게 만들어지지 않았기때문에 각스레드마다
별개로 가져야한다. 그러나 명령 큐는 스레드 안전하게 만들어졋기 때문에 여러 쓰레드가 큐에 병렬적으로
명령리스트를 추가할 수 있다.
구체적인 방법으로는 쓰레드개수와 패스개수가 같은 패스기반 방식과 씬이나 패스를 아주 작은 크기로 쪼개고
작은 것들을 여러쓰레드로 병렬 처리하는 청크기반 방식이 있다.
스키닝 애니메이션
사용되는 스키닝 캐릭터 모델은 계층 구조로 이루어져있는데 보통 루트 프레임에 스킨 메쉬가 포함되어 있습니다.
스키닝 애니메이션은 뼈대를 따라 피부 메쉬가 움직일때 관절 부위에서 메쉬가 연결되지않고 틈이 생기기 때문에 뼈가
움직일 때 뼈에 영향을 받는 정점을 블렌딩해서 그리는 방법입니다.
정점을 얻기 위해서는오프셋 행렬을 통해서 프레임 좌표계 정점을 얻을 수있고, 스킨 메시에서 각정점마다 영향을 받는
뼈들의 정보를 리스트로 저장하고, 보통 최대 4개까지 영향을 받습니다. 그리고 각각의 뼈가 정점에 얼마나 영향을 받는지를
나타내는 가중치가 필요합니다. 이 가중치들의 합은 1.0이되고 정점 변환시 가중치를 적용하여 블렌딩합니다.
스텐실검사 + 깊이 검사
스텐실 검사는 렌더타겟에 일부영역을 렌더링하지않는것이 주기능임
비교연산을 통해 검사하고, 검사 통과시 현재 색상을 렌더 타겟에 쓰고 새로운 스텐실 값을 버퍼에 넣는다.
거울 반사에서 대표적으로 사용된다.
깊이검사와 스텐실 검사는 독립적으로일어난다.
깊이검사가 비활성이면 디폴트로 성공으로 처리하고, 이후 깊이쓰기가 발생하는데
깊이쓰기 이전에 스텐실검사를 수행한다. 스텐실 검사 또한 비활성이면 디폴트로 성공이고
깊이검사와 스텐실검사둘다가 성공해야만 깊이 쓰기가 발생한다.
스텐실 은 두검사의 결과와 관계없이 쓰기가 일어나고 값이 만들어진다.
최종적으로 두검사를 통과해야만 렌더링이 된다.
지연조명
조명처리 최적화
방향성 조명은 전체 영향이기에 의미가없지만, 스팟 라이트와 포인트라이트의 경우 조명볼륨을 생성하고
절두체와 충돌이되는 모든 조명볼륨을 찾고, 평면거울과 유사한 방법으로 스텐실에 해당영역을 표기하고
스텐실 값이1인 부분만 조명 계산을하여 최적화를 한다.
지연 쉐이딩
씬렌더링과 조명렌더링을 두개로 나누고 조명 계산을 뒤로 미루는 방법이다.
조명 계산에 필요한 정보들은 픽셀쉐이더에서 텍스처에 따로 저장한다.(Position,UV,Normal)
이러한 것들을 쥐 버퍼라고한다. 이 부분은 렌더타겟에 출력만 하므로 시간적 문제가없다
후면 버퍼에 화면크기의 사각형을 그리고 쥐버퍼의 정보를 사용해서 조명 계산을 한다.
화면 크기의 픽셀에 대해서만 계산을 하기 때문에 씬의 복잡도에 관계없이 상수시간내에 끝나게된다.
G버퍼에 법선 저장시 컬러로 바꾸어 XY만 저장하고 구의 방정식을 이용하여 z를 계산해서 만든다. 사용시에는 디코딩이 필요
단점은 정보 저장 과정에서 블랜딩 처리가 안되기 때문에 투명효과 처리가 불가능하고 재질이 많을때 관리가 어렵다.
그림자
그림자는 시각적 현실감을 느끼게한다.지면에 붙었는지 털어졌는지 표현할 수 있다.
원형 그림자
그림자 텍스처를 지면에 그려서 그림자를 표현하는 방법, 블렌딩을 이용한다.
가장 간단한 방법이고 크기 농도를 쉽게 조정할 수 있다.
평면 투영 그림자
조명에서 정점을 지나는 광선이 지면과 교차하는점을 구하고 그점을 사용해 그림자를 그리는 방법이다.
평면 투영행렬과 정점을 곱해 교차점을 구할 수 있는데 이 행렬은 평면의 방정식의 a b c d와 방향성 광원의 경우
조명의 반대 방향 벡터와 w값에는 0을 점광원의 경우 위치벡터와 w를 1로 함수에 전달하면 행렬을 얻을 수 있다.
그림자 매핑
조명위치에 카메라를 옮겨서 깊이를 저장할 텍스처를 생성하고 렌더 타겟으로 설정후 검정색으로 채운다.
그 위에 객체를 흰색으로 모델링하고 이때 생성된 텍스처를 원형 그림자처럼 렌더링한다.
그림자 맵은 조명이 객체에 도달 여부를 계산하여 텍스처에 저장된것이다.
렌더링 시 조명에서 픽셀까지 거리와 그림자 맵에 저장된 깊이값을 비교하여 그림자 여부를 판별한다.
그림자 맵의 깊이값을 알려면 uv값을 알아야하는데, 객체의 정점을 조명좌표계로 바꾸고 텍스처 좌표계로 바꾸면 uv가 된다.
판별 후에 그림자가맞다면 해당 픽셀에 그림자로 그리게된다.
투영이나 원근으로 인해서 계단현상이 발생하는데 새도우 맵의 해상도를 높이면 오차가 줄어 해결이되지만,
비디오 메모리를 그만큼 많이 차지하고 샘플링 시간이 늘어나서 FPS가 문제가 생기게된다.
방향성 조명의 경우 계단현상을 위해  하나의 고해상도 그림자맵보다 
절두체를 여러 영역으로 나누어 분할하고 별도의 그림자 맵을 생성해 공간이 낭비되는것을 줄일 수 있다.
또다른 문제로 그림자 여드름이 있는데 이 때 적당한 바이어스를 그림자맵의 깊이값에 더하면 해결이된다.
너무 크게주면 피터팬 효과가 발생할 수도 있다.