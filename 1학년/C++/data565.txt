

--------------------------------------------------
Sat Sep 16 01:34:20 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <random>
#include <algorithm>


using namespace std;
void save();		// save()라는 함수를 선언(decalraration)


					//[문제] 1000만개의 정수를 담을 수 있는 공간을 동적할당하라.
					// 정수의 값을 랜덤엔짐과 분포를 사용하여 임의의 값으로 채워라.
					// 1000만개의 정수를 오름차순으로 정렬하라.
					// 앞에서부터 1000개의 값을 화면 출력하라.
					//
					// 여기서 정렬알고리즘은 STL의 sort를 이용한다.

int main()
{
	//sort 사용 예

	/*int num[10] {1,3,5,7,9,2,4,6,8,10};

	sort(&num[0],&num[10]);  //sort(정렬시작번지, 정렬끝번지+1);

	for (int d : num)
	cout << d << endl;*/


	int* p = new int [10000000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000000);

	for (int i = 0; i <= 10000000; ++i)
		p[i] = uid(dre);

	sort(p, p+10000000);

	for (int j = 0; j <= 1000; ++j)
		cout << p[j] << endl;

	delete[] p;



	save();
}


--------------------------------------------------
Mon Sep 18 12:46:41 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <random>
#include <algorithm>


using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//동적할당(dynamic allocation)
//c언어에서는 malloc - free를 사용
//c++언어에서는 new - delete를 사용한다.
//
//메모리는 컴퓨터의 주요 자원이다.
//필요할 때 요청해서 메모리를 할당받고(new)
//사용이 끝난 후 반환(delete)하여야 한다.
//메모리는 자유메모리공간(HEAP)에서 할당받는다.

//[문제] HEAP도 유한한 크기를 갖는다.
//HEAP을 넘치게 해보자


int main()
{
	//while (true)
	new int;  //int가 들어갈 공간을 HEAP에서 할당받는다.

	save();
}


--------------------------------------------------
Mon Sep 18 13:00:36 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <random>
#include <algorithm>


using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//동적할당(dynamic allocation)
//c언어에서는 malloc - free를 사용
//c++언어에서는 new - delete를 사용한다.
//
//메모리는 컴퓨터의 주요 자원이다.
//필요할 때 요청해서 메모리를 할당받고(new)
//사용이 끝난 후 반환(delete)하여야 한다.
//메모리는 자유메모리공간(HEAP)에서 할당받는다.

//[문제] HEAP도 유한한 크기를 갖는다.
//HEAP을 넘치게 해보자


int main()
{
	//메모리 사용 순서 - 단독으로 요청하는 경우
	int* p = new int;     //1. 필요한 크기를 요청한다
	*p = 123;             //2. 사용
	delete p;             //3, 반환

	//메모리 사용 순서 - 배열으로 요청하는 경우
	int* q = new int[10]; //1. 필요한 크기를 요청한다
	for (int i = 0; i < 10; ++i)
		q[i] = i;         //2. 사용
	delete[] q;           //3, 반환
	save();
}


--------------------------------------------------
Mon Sep 18 13:34:50 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <random>
#include <algorithm>


using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



int main()
{
	//메모리가 필요해서 요청한 순간과
	//필요가 없어서 해제한 순간사이의 시간은 얼마나 될까?
	\
		int* p = new int;   //int*는 POD(Plain Old Data) 타입이다.

		// 이 사이는 수많은 시간
		// 서로 다른공간(file)으로 분리되어 있다.
		// -->
		// [문제점] new와 delete의 짝이 맞지 않을 확률이 클 것이다.
		// [해결책] 자신이 가리키는 자원을 자신이 소멸될때 해제할 수 있는
		//       스마트 포인터를 사용하면 된다. (c++언어의 unique_ptr)

		delete p;
	\
	save();
}


--------------------------------------------------
Mon Sep 18 13:36:01 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>



using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



int main()
{
	//메모리가 필요해서 요청한 순간과
	//필요가 없어서 해제한 순간사이의 시간은 얼마나 될까?
	
		//int* p = new int;   //int*는 POD(Plain Old Data) 타입이다.
	    unique_ptr<int> s(new int);
		
		//delete p;
	
	save();
}


--------------------------------------------------
Mon Sep 18 13:36:30 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>



using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



int main()
{
	//메모리가 필요해서 요청한 순간과
	//필요가 없어서 해제한 순간사이의 시간은 얼마나 될까?
	
		//int* p = new int;   //int*는 POD(Plain Old Data) 타입이다.
	    unique_ptr<int> s(new int);
		
		
	
	save();
}


--------------------------------------------------
Mon Sep 18 13:40:46 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>



using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//범위기반의 for loop
// - 범위를 알 수 있는 자료구조에서 모든 data에 access 하는 경우
//   범위를 지정하지 않아도 되는 for loop임. (C++11)


int main()
{
	
	char a[] = "the quick brown fox jumps over the lazy dog";

	for (char c : a)
		cout << c << '-';
	cout << endl;
	
	save();
}


--------------------------------------------------
Mon Sep 18 13:43:42 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>

using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//범위기반의 for loop
// - 범위를 알 수 있는 자료구조에서 모든 data에 access 하는 경우
//   범위를 지정하지 않아도 되는 for loop임. (C++11)


int main()
{
	
	char a[] = "the quick brown fox jumps over the lazy dog";

	sort(a, a + strlen(a));

	for (char c : a)
		cout << c << '-';
	cout << endl;
	
	save();
}


--------------------------------------------------
Mon Sep 18 13:44:37 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>

using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//범위기반의 for loop
// - 범위를 알 수 있는 자료구조에서 모든 data에 access 하는 경우
//   범위를 지정하지 않아도 되는 for loop임. (C++11)


int main()
{
	
	char a[] = "the quick brown fox jumps over the lazy dog";

	sort(a, a + strlen(a));

	for (char c : a)
		cout << c;
	cout << endl;
	
	save();
}


--------------------------------------------------
Mon Sep 18 13:45:29 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>

using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

//범위기반의 for loop
// - 범위를 알 수 있는 자료구조에서 모든 data에 access 하는 경우
//   범위를 지정하지 않아도 되는 for loop임. (C++11)


int main()
{
	
	char a[] = "the quick brown fox jumps over the lazy dog";

	sort(a, a + strlen(a));
	unique(a, a + strlen(a));
	for (char c : a)
		cout << c;
	cout << endl;
	
	save();
}


--------------------------------------------------
Mon Sep 18 14:09:24 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력

const int NUM = 1000000;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	int x = *(int*)a;
	int y = *(int*)b;


	if (x > y)
		return 1;
	if (x < y)
		return -1;
	return 0;
}

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;

	int* p = new int[NUM];

	for (int i = 0; i < NUM; ++i)
		p[i] = uid(dre);

	qsort(p, NUM, sizeof(int), comp);
	
	ofstream out("Random_Number.txt");
	
	for (int i = 0; i < NUM; ++i)
		out << p[i] << " ";

	ifstream in("Random_Number.txt");
	int n;
	for (int i = 0; i < 10; ++i){
		in >> n;
	    cout << n;
	}
	save();
}


--------------------------------------------------
Mon Sep 18 14:10:39 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력

const int NUM = 1000000;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	int x = *(int*)a;
	int y = *(int*)b;


	if (x > y)
		return 1;
	if (x < y)
		return -1;
	return 0;
}

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;

	int* p = new int[NUM];

	for (int i = 0; i < NUM; ++i)
		p[i] = uid(dre);

	qsort(p, NUM, sizeof(int), comp);
	
	ofstream out("Random_Number.txt");
	
	for (int i = 0; i < NUM; ++i)
		out << p[i] << " ";

	ifstream in("Random_Number.txt");
	int n;
	for (int i = 0; i < 10; ++i){
		in >> n;
	    cout << n << " ";
		cout << endl;
	}
	save();
}


--------------------------------------------------
Mon Sep 18 14:12:51 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (1주 2)
//한 학기 강의를 저장할 수 있도록 save()를 만듬
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
// 9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
// 9.22 - 함수 ->callable type, overloading, lambda
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력

const int NUM = 1000000;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	int x = *(int*)a;
	int y = *(int*)b;


	if (x > y)
		return 1;
	if (x < y)
		return -1;
	return 0;
}

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid;

	int* p = new int[NUM];

	for (int i = 0; i < NUM; ++i)
		p[i] = uid(dre);

	qsort(p, NUM, sizeof(int), comp);
	
	ofstream out("Random_Number.txt");
	
	for (int i = 0; i < NUM; ++i)
		out << p[i] << " ";

	ifstream in("Random_Number.txt");
	int n;
	for (int i = 0; i < 10; ++i){
		in >> n;
	    cout << n << " ";
		cout << endl;
	}

	delete[] p;
	save();
}


--------------------------------------------------
Fri Sep 22 14:10:29 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//
int cmp(const void* a, const void* b);

int main()
{
	//람다가 C++11에 도입됨으로써 함수가 지역내에서도 정의가능하게 되었다.
	[]() -> void {
		cout << "hello wold" << endl;
	}();
	save();
}




--------------------------------------------------
Fri Sep 22 14:13:21 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//

auto add(int, int) -> int;

auto add(int a, int b) -> decltype(a + b)
{
	return a + b;
}
int main()
{
	cout << add(3, 4) << endl;
	save();
}




--------------------------------------------------
Fri Sep 22 14:15:34 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//




int main()
{
	// 정수 2개를 인자로 받아 합을 리턴하는 람다를 정의하고
	// 3,4를 인자로 호출해보라

	[](int a , int b) -> int {
		return a + b;
	}(3,4);

	save();
}




--------------------------------------------------
Fri Sep 22 14:17:20 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//




int main()
{
	// 정수 2개를 인자로 받아 합을 리턴하는 람다를 정의하고
	// 3,4를 인자로 호출해보라

	[](int a , int b) -> int {
		cout << a + b << endl;
		return a + b;
	}(3,4);

	save();
}




--------------------------------------------------
Fri Sep 22 14:18:16 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//




int main()
{
	// 정수 2개를 인자로 받아 합을 리턴하는 람다를 정의하고
	// 3,4를 인자로 호출해보라
	int x;
	x=[](int a , int b) -> int {
		
		return a + b;
	}(3,4);

	cout << x << endl;

	save();
}




--------------------------------------------------
Fri Sep 22 14:19:22 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <memory>
#include <algorithm>
#include <string>
#include <random>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

// 정수 100만개를 랜덤값(범위x)으로 채워
// qsort() 오름차순
//전체 정렬된 data를 파일에 저장
//정렬된 파일을 읽어 앞에서 10개의 값을 화면 출력


// callable type
// - 어떤 자료형이 호출 가능하다면 이것을 호출가능타입이라고 한다.
//
//1.일반 함수
//2.함수 포인터
//3.이름없는 함수(lamda) - 구글링 해볼것
// []() {};
// [] - 람다 도입자, lamda introducer
// () - 전달인자
// {} - 함수의 몸체
//




int main()
{
	// 정수 2개를 인자로 받아 합을 리턴하는 람다를 정의하고
	// 3,4를 인자로 호출해보라
	
	cout << [](int a , int b) -> int {
		
		return a + b;
	}(3,4 ) << endl;

	

	save();
}




--------------------------------------------------
Fri Sep 22 14:43:52 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)




//람다는 어디에 사용하는가
//->직접 함수를 호출하지 않고 함수의 기능만 필요한 곳에 사용한다.
//->함수내의 인자로 함수를 전달하는 곳에 사용한다.


//[문제] 키보드에서 단어를 입력받아 오름차순으로 정렬한 후 출력하라.



int main()
{
	
	vector<string> v;

	copy(istream_iterator<string>(cin), istream_iterator<string>(),
		back_inserter(v));

	sort(v.begin(), v.end()); // default 오름차순 정렬

	for (string d : v)
		cout << d << "\t";
	cout << endl;
	

	save();
}




--------------------------------------------------
Fri Sep 22 14:45:04 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)




//람다는 어디에 사용하는가
//->직접 함수를 호출하지 않고 함수의 기능만 필요한 곳에 사용한다.
//->함수내의 인자로 함수를 전달하는 곳에 사용한다.


//[문제] 키보드에서 단어를 입력받아 오름차순으로 정렬한 후 출력하라.



int main()
{
	
	vector<string> v;

	copy(istream_iterator<string>(cin), istream_iterator<string>(),
		back_inserter(v));

	sort(v.begin(), v.end()); // default 오름차순 정렬

	for (string d : v)
		cout << d << "\t";
	cout << endl;
	

	save();
}




--------------------------------------------------
Fri Sep 22 14:46:21 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)




//람다는 어디에 사용하는가
//->직접 함수를 호출하지 않고 함수의 기능만 필요한 곳에 사용한다.
//->함수내의 인자로 함수를 전달하는 곳에 사용한다.


//[문제] 키보드에서 단어를 입력받아 오름차순으로 정렬한 후 출력하라.



int main()
{
	
	vector<string> v;

	copy(istream_iterator<string>(cin), istream_iterator<string>(),
		back_inserter(v));

	sort(v.begin(), v.end()); // default 오름차순 정렬

	for (string d : v)
		cout << d << "\t";
	cout << endl;
	

	save();
}




--------------------------------------------------
Fri Sep 22 14:48:42 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)




//람다는 어디에 사용하는가
//->직접 함수를 호출하지 않고 함수의 기능만 필요한 곳에 사용한다.
//->함수내의 인자로 함수를 전달하는 곳에 사용한다.


//[문제] 키보드에서 단어를 입력받아 오름차순으로 정렬한 후 출력하라.



int main()
{
	
	vector<string> v;

	copy(istream_iterator<string>(cin), istream_iterator<string>(),
		back_inserter(v));
	//내립차순은?
	sort(v.begin(), v.end(), [](string a, string b)-> bool {
		return a > b;
	});

	for (string d : v)
		cout << d << "\t";
	cout << endl;
	

	save();
}




--------------------------------------------------
Fri Sep 22 14:50:53 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)




//람다는 어디에 사용하는가
//->직접 함수를 호출하지 않고 함수의 기능만 필요한 곳에 사용한다.
//->함수내의 인자로 함수를 전달하는 곳에 사용한다.


//[문제] 키보드에서 단어를 입력받아 오름차순으로 정렬한 후 출력하라.



int main()
{
	int n = 100;

	[n]() {
		cout << n << endl;
	}();
	

	save();
}




--------------------------------------------------
Fri Sep 22 14:56:18 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



//C++의 함수 오버로딩(overloading)
//--> C**에서는 같은 이름의 함수를 선언하고 정의할 수 있다. (컴파일러가 구분가능하다면)

void add(char, char) { cout << 1 << endl; };
void add(int, int) { cout << 2 << endl; };
void add(int, int, int) { cout << 3 << endl; };

int main()
{
	add('a', 'b');
	add(3, 4);
	add(3, 4, 5);

	save();
}




--------------------------------------------------
Fri Sep 22 14:56:52 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



//C++의 함수 오버로딩(overloading)
//--> C**에서는 같은 이름의 함수를 선언하고 정의할 수 있다. (컴파일러가 구분가능하다면)

void add(char, char) { cout << 1 << endl; };
void add(int, int) { cout << 2 << endl; };
void add(int, int, int) { cout << 3 << endl; };

int main()
{
	add((int)'a', (int)'b');
	add(3, 4);
	add(3, 4, 5);

	save();
}




--------------------------------------------------
Fri Sep 22 14:58:02 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



//C++의 함수 오버로딩(overloading)
//--> C**에서는 같은 이름의 함수를 선언하고 정의할 수 있다. (컴파일러가 구분가능하다면)

void add(char, char) { cout << 1 << endl; };
void add(int, int) { cout << 2 << endl; };
void add(int, int, int) { cout << 3 << endl; };
void add(int, char) { cout << 4 << endl; };

int main()
{
	add((int)'a', 'b');
	add(3, 4);
	add(3, 4, 5);

	save();
}




--------------------------------------------------
Fri Sep 22 15:04:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



//C++의 함수 오버로딩(overloading)
//--> C**에서는 같은 이름의 함수를 선언하고 정의할 수 있다. (컴파일러가 구분가능하다면)
//
// 동일한 이름의 함수를 여러개 만들면
//C++ 컴파일러는 함수의 이름을 임의로 변경한다.(name magling)

int main()
{

	save();
}




--------------------------------------------------
Fri Sep 22 15:14:20 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)


// 프로그램은 1, 2, 4, 8 바이트 변수가지고 만들 수 없다
// 이거 가지고 뭘 만들 수 있겠는가?
// --> 기존의 오래된 자료형(POD : Plain Old Data type)
//
// 사용자가 원하는 만큼의 메모리를 확보하는 방법은 없겠니?
// --> 사용자 정의 자료형(User Defined Data type)
// --> 모든 프로그래밍 언어는 사용자 마음대로 자료형을 만들 수 있는 방법을 제공한다
// --> C++에서는 struct와 class 키워드를 사용하여 그렇게 할 수 있다.

class Dragon {  // Dragon 이라는 자료형을 정의한다.
	string name;
	int age;

};

int main()
{
	
	Dragon a;

	cout << "드래곤의 크기는" << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Fri Sep 22 15:14:34 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)


// 프로그램은 1, 2, 4, 8 바이트 변수가지고 만들 수 없다
// 이거 가지고 뭘 만들 수 있겠는가?
// --> 기존의 오래된 자료형(POD : Plain Old Data type)
//
// 사용자가 원하는 만큼의 메모리를 확보하는 방법은 없겠니?
// --> 사용자 정의 자료형(User Defined Data type)
// --> 모든 프로그래밍 언어는 사용자 마음대로 자료형을 만들 수 있는 방법을 제공한다
// --> C++에서는 struct와 class 키워드를 사용하여 그렇게 할 수 있다.

class Dragon {  // Dragon 이라는 자료형을 정의한다.
	string name;
	int age;

};

int main()
{
	
	Dragon a;

	cout << "드래곤의 크기는 " << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Fri Sep 22 15:15:19 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)


// 프로그램은 1, 2, 4, 8 바이트 변수가지고 만들 수 없다
// 이거 가지고 뭘 만들 수 있겠는가?
// --> 기존의 오래된 자료형(POD : Plain Old Data type)
//
// 사용자가 원하는 만큼의 메모리를 확보하는 방법은 없겠니?
// --> 사용자 정의 자료형(User Defined Data type)
// --> 모든 프로그래밍 언어는 사용자 마음대로 자료형을 만들 수 있는 방법을 제공한다
// --> C++에서는 struct와 class 키워드를 사용하여 그렇게 할 수 있다.

class Dragon {  // Dragon 이라는 자료형을 정의한다.
	string name;
	int age;

};

int main()
{
	
	Dragon a;

	cout << "드래곤의 크기는 " << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Fri Sep 22 15:15:23 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)


// 프로그램은 1, 2, 4, 8 바이트 변수가지고 만들 수 없다
// 이거 가지고 뭘 만들 수 있겠는가?
// --> 기존의 오래된 자료형(POD : Plain Old Data type)
//
// 사용자가 원하는 만큼의 메모리를 확보하는 방법은 없겠니?
// --> 사용자 정의 자료형(User Defined Data type)
// --> 모든 프로그래밍 언어는 사용자 마음대로 자료형을 만들 수 있는 방법을 제공한다
// --> C++에서는 struct와 class 키워드를 사용하여 그렇게 할 수 있다.

class Dragon {  // Dragon 이라는 자료형을 정의한다.
	string name;
	int age;

};

int main()
{
	
	Dragon a;

	cout << "드래곤의 크기는 " << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 12:46:14 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)






class Dragon {  
	char d[30000];

};

int main()
{
	
	Dragon a;
	
	cout << "드래곤의 크기는 " << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 12:46:42 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)






class Dragon {  
	int* p;
	char d[30000];

};

int main()
{
	
	Dragon a;
	
	cout << "드래곤의 크기는 " << sizeof(Dragon) << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 12:54:08 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
public:	
	string name;
	int age;

};

int main()
{
	
	Dragon a;
	a.name = "드래곤";


	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 12:54:33 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
public:	
	string name;
	int age;

};

int main()
{
	
	Dragon a;
	a.name = "드래곤";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:02:57 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
public:
	string name;
	int age;

	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

};

int main()
{
	
	Dragon a;
	a.name = "수민룡";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:03:13 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
public:
	string name;
	int age;

	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

};

int main()
{
	
	Dragon a;
	a.name = "\t수민룡\t";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:03:22 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
public:
	string name;
	int age;

	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

};

int main()
{
	
	Dragon a;
	a.name = "\t수민룡\t";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:05:31 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
public:
	string name;
	int age;

	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

};

int main()
{
	
	Dragon a;
	a.name = "\t수민룡(완전쌤)\t";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:05:48 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
public:
	string name;
	int age;

	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

};

int main()
{
	
	Dragon a;
	a.name = "\t수민룡(완전쎄다)\t";

	cout << a.name << endl;
	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.

	save();
}




--------------------------------------------------
Mon Sep 25 13:19:08 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	int n;
	
	cin >> n;

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은" << a.getName() << "나이는" << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:19:29 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은" << a.getName() << "나이는" << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:20:37 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은" << a.getName() << "나이는" << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:21:17 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은" << a.getName() << "나이는" << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:22:04 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은" << a.getName() << "나이는" << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:40:00 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 접근 가능하다
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}
public:
	string getName() {
		cin >> name;
		return name;
	}
public:
	int getAge() {
		cin >> age;
		return age;
	}
};

int main()
{
	
	Dragon a;
	//Dragon 타입의 객체 a를 만들때(instancing)
	//a의 이름과 나이를 설정하는것이 맞다.
	//만들어질때?
	//어떻게?

	//Dragon의 이름을 알고싶다/바꾸고 싶다/만들고 싶다.
	//name과 같은 멤버변수에 직접 access하는 것은 금지한다.
	//대신 멤버함수(getter/setter)를 사용하여 access하도록 프로그램한다.

	cout << "용의 이름은 " << a.getName() << "나이는 " << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 13:56:49 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//숙제 - C++ 책이나 구글에서 class 읽어보기
// --> 숙제 후 질문 : struct와 class의 차이점
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 얼마든지 요청 가능하다.
	Dragon(string name, int age) : name(name), age(age) {

	}
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

	string getName() {
		return name;
	}

	int getAge() {
		return age;
	}

	void setName(string str)  {
		name = str;
	}
};

int main()
{
	
	Dragon a("창식이",10);
	
	a.setName("창식이2");

	cout << "용의 이름은 " << a.getName() << " 나이는 " << a.getAge() << endl;
	save();
}




--------------------------------------------------
Mon Sep 25 14:12:22 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
#include <vector>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



class Dragon {  
	//객체를 프로그램으로 표현하는 방법
	//1. 변수 - 수치화 할 수 있는 객체의 특성들(attribute)
	//   name, age
	//   메모리(STACK,DATA,HEAP)를 차지하며 값을 읽고 쓸 수 있다
	//2. 함수 - 객체의 행동을 표현하는 코드(behavior)
	//   fly
	//   CODE 영역에 기록되며 객체의 메모리와는 관계가 없다.
private:
	string name; //멤버변수는 바꾸지 못하게 하는 것이 기본이다.
	int age;
public:          //동작은 얼마든지 요청 가능하다.
	Dragon() : name("무명", -1){
		cout << "default_constructor" << endl;
	}

	Dragon(string name, int age) : name(name), age(age) {

	}
	void fly() {
		cout << "용이 하늘을 난다" << endl;
	}

	string getName() const {
		return name;
	}

	int getAge() const {
		return age;
	}

	void setName(string str)  {
		name = str;
	}
};

int main()
{
	save();
	Dragon a; //RAII Dragon();
	
}




--------------------------------------------------
Mon Sep 25 14:16:57 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)



//class와 struct의 차이점
// - 둘 다 사용자 정의 자료형을 만든다
// - 둘 다 멤버변수와 멤버함수를 사용할 수 있다.
// - c와 달리 c++에서 class와 struct는 기능에서 차이가 없다
//  오늘 만든 class Dragon을 struct Dragon으로 바꿔도 아무 차이가 없다
//
//그럼 뭐가 다른 점인가?
//struct는 기본 access 지정자가 public이고
//class는  기본 access 지정자가 private이라는 점이 유일한 차이점이다.
//
//C++에서는 언제 struct를 사용하는가?
//모든 멤버가 public이 합당하다면 struct를 사용한다.
//



int main()
{
	save();
	
	
}




--------------------------------------------------
Fri Sep 29 13:44:47 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Mario
{
	char Luigi[1234];
};



// 나는 1234바이트를 갖는 자료형을 만들고 싶다.


int main()
{
	
	Mario a; //a를 이용하여 1234에 access
	         //a는 1234바이트의 시작번지가 된다
	
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 13:44:50 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Mario
{
	char Luigi[1234];
};



// 나는 1234바이트를 갖는 자료형을 만들고 싶다.


int main()
{
	
	Mario a; //a를 이용하여 1234에 access
	         //a는 1234바이트의 시작번지가 된다
	
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 13:49:32 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Mario
{
public:
	char Luigi[1234];
};



// 나는 1234바이트를 갖는 자료형을 만들고 싶다.


int main()
{
	
	Mario a; //a를 이용하여 1234에 access
	         //a는 1234바이트의 시작번지가 된다
	
	void* p = (&a);
	char* pc = (char*)p;
	*pc = 'X';


	cout << a.Luigi[0] << endl;
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 13:49:57 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Mario
{
public:
	char Luigi[1234];
};



// 나는 1234바이트를 갖는 자료형을 만들고 싶다.


int main()
{
	
	Mario a; //a를 이용하여 1234에 access
	         //a는 1234바이트의 시작번지가 된다
	
	void* p = (&a);
	char* pc = (char*)p;
	*pc = 'X';


	cout << a.Luigi << endl;
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:04:05 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
};



int main()
{
	Dragon d("용가리",10);
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:06:43 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 생성함" << endl;
    }
};



int main()
{
	Dragon d("용가리",10);
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:08:04 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 생성함" << endl;
    }
};



int main()
{
	{
	Dragon d("용가리",10);
	}
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:09:36 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 생성함" << endl;
    }
};



int main()
{
	{
	Dragon d("용가리",10);
	Dragon c("창식이", 100);
	}
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:10:18 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 소멸함" << endl;
    }
};



int main()
{
	{
	Dragon d("용가리",10);
	Dragon c("창식이", 100);
	}
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:11:14 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 소멸함" << endl;
    }
};

Dragon d("용가리",10);
	Dragon c("창식이", 100);
	

int main()
{
	
	
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:12:17 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 소멸함" << endl;
    }
};

Dragon d("용가리",10);
	Dragon c("창식이", 100);
	

int main()
{
	Dragon c("ㄷㄷㄷㄷ창식이", 0);
	
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:16:08 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 소멸함" << endl;
    }
};



int main()
{
	Dragon d[3]{ {"창식이",3},{"데스윙",6000},{"네파리안",8000} };
	
	save();
    	
	
}




--------------------------------------------------
Fri Sep 29 14:29:13 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"   //save 함수의 선언은 여기에
#include <algorithm>
#include <string>
#include<iterator>
using namespace std;
void save();		// save()라는 함수를 선언(decalraration)

class Dragon
{
	
private:            //멤버변수 - 클래스의 속성, 특성값 - attribute
	string name;
	int age;
public:             //멤버함수 - 클래스의 행동, 인터페이스 - behavior
	Dragon(){}
	Dragon(string name, int age) : name(name), age(age) {
		cout << name << "," << age << "살인 용을 생성함" << endl;
	}
	~Dragon(){
		cout << name << "," << age << "살인 용을 소멸함" << endl;
    }
};



int main()
{
	Dragon d[300];
	
	save();
    	
	
}




--------------------------------------------------
Fri Oct 13 14:44:21 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;



int main()
{
	{
		ofstream out("정수 1000개");
		for (int i = 0; i < 1000; ++i){
			int x = i*i;
		out.write((char*)&x , 4);
		}
	}
	save();

}








--------------------------------------------------
Fri Oct 13 15:02:08 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번


//사용자 정의 자료형(User Defined Data Type)이란?
//기존의 자료형(Plain Old Data Type : POD)에 비하여 말 그대로 프로그래머가
//원하는 만큼의 메모리를 확보할 수 있도록 해준다.
//C++에서는 class라는 keyword를 사용하여 사용자 정의 자료형을 만들 수 있다.
//C에서는   struct를 사용하여 사용자 정의 자료형을 만들 수 있었다.
//그러나 C와는 달리 C++에서는 자료형이 메모리만을 의미하지 않는다.
//C++에서는 메모리말고 동작을 하나의 자료형에 묶을 수 있다.(객체지향 프로그래밍)
//
//즉, class 내에
//객체의 속성을 나타내는 멤버 변수 (member variable)외에
//객체의 행동을 나타내는 멤버 함수 (member variable)을 같이 정의할 수 있다.
//지난 시간에 살펴 본것과 같이 내가 만든 객체의 크기는 멤버변수로만 결정된다.
//
//객체가 메모리에 만들어지는 것을 instancing이라는 용어를 사용한다.
//class에서는 객체가 메모리에 만들어진후(메모리는 내가 잡을 수 없다)
//그 메모리의 내용을 채울 기회를 준다.(생성자함수가 그런일을 하는 곳이다.)
//
//메모리는 언젠가는 사라진다. 객체도 메모리이다.
//class로 만든 객체는 사용자가 만든 것이다.
//그래서 메모리가 사라지기 전에(내가 객체를 지울 수는 없다)
//그 메모리의 내용을 정리할 기회를 제공한다. (소멸자함수 그런일을 하라고 있는 거다)
//
// class에서 제일 재밌는 것은 생성자, 소멸자와 같은 특별한 함수를 이용하여
// 화면에 메시지를 출력함으로써 객체의 생성, 소멸 등을 직접 관찰할 기회가 있다는 것이다.

int main()
{
	int n;

	save();
}








--------------------------------------------------
Fri Oct 13 15:07:11 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

class Dragon {
public:
	Dragon() {  //클래스이름과 같은 생성자 함수
		cout << "디폴트 생성자" << endl;
	}
};
int main()
{
	Dragon n;

	save();
}








--------------------------------------------------
Fri Oct 13 15:10:19 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

class Dragon {
public:
	Dragon() {  //클래스이름과 같은 생성자 함수
		cout << "디폴트 생성자" << endl;
	}
	~Dragon() {
		cout << "소멸자" << endl;
	}
};
int main()
{
	Dragon n;

	save();
}








--------------------------------------------------
Fri Oct 13 15:15:18 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번


int main()
{
	int n;
	//int 읽고 쓰고 초기화 참조 외에 함수로 전달 리턴으로 전달

	save();
}








--------------------------------------------------
Fri Oct 13 15:20:01 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

class Dragon{
public:
	Dragon()
	{
		cout << "디폴트 생성자" << endl;
	}
	Dragon(const Dragon&)
	{
		cout << "복사 생성자" << endl;
	}
	~Dragon()
	{
		cout << "소멸자" << endl;
	}
};
void f(Dragon) {};

int main()
{
	Dragon a;

	f(a);
	save();
}








--------------------------------------------------
Mon Oct 16 12:48:32 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{
private:
	string name = "없음";
	int age = -1;
public:
	Dragon()
	{

	}
	Dragon(string name, int age)
	{
		
	}
	Dragon(const Dragon&)
	{
		
	}
	~Dragon()
	{
		
	}
	void show()
	{
		cout << "이름 - " << name << "," << "나이" << age << "살" << endl;
	}
};


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 12:49:13 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{
private:
	string name = "없음";
	int age = -1;
public:
	Dragon()
	{

	}
	Dragon(string name, int age) : name(name), age(age)
	{
		
	}
	Dragon(const Dragon&)
	{
		
	}
	~Dragon()
	{
		
	}
	void show()
	{
		cout << "이름 - " << name << "," << "나이" << age << "살" << endl;
	}
};


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 12:49:23 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{
private:
	string name = "없음";
	int age = -1;
public:
	Dragon()
	{

	}
	Dragon(string name, int age) : name(name), age(age)
	{
		
	}
	Dragon(const Dragon&)
	{
		
	}
	~Dragon()
	{
		
	}
	void show()
	{
		cout << "이름 - " << name << "," << "나이 " << age << "살" << endl;
	}
};


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 12:49:30 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{
private:
	string name = "없음";
	int age = -1;
public:
	Dragon()
	{

	}
	Dragon(string name, int age) : name(name), age(age)
	{
		
	}
	Dragon(const Dragon&)
	{
		
	}
	~Dragon()
	{
		
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 12:50:03 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{
private:
	string name = "없음";
	int age = -1;
public:
	Dragon(){}
	Dragon(string name, int age) : name(name), age(age)
	{
		
	}
	
	~Dragon(){	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:00:43 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon()
	{
		name = "없음";
		age = -1;
	}
	Dragon(string name, int age) : name(name), age(age)
	{
		
	}
	
	~Dragon(){	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

/*Dragon::Dragon()
{
	name = "없음";
	age = -1;
}*/

int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:02:28 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1)
	{
		//name = "없음";
		//age = -1;
	}
	Dragon(string name, int age) : name(name), age(age){	
	}
	
	~Dragon(){	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

/*Dragon::Dragon()
{
	name = "없음";
	age = -1;
}*/

int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:09:25 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) { cout << "생성" << endl; }
	Dragon(string name, int age) : name(name), age(age){	
	}
	
	~Dragon()
	{
		cout << "소멸" << endl;
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

// 객체의 생성과 소멸을 화면출력으로 관찰해보자


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:11:06 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) { cout << "생성" << endl; }
	Dragon(string name, int age) : name(name), age(age){	
		cout << "생성" << endl;
	}
	
	~Dragon()
	{
		cout << "소멸" << endl;
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

// 객체의 생성과 소멸을 화면출력으로 관찰해보자


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:16:53 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) { cout << "생성" << endl; }
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor" << endl;
		show();
	}
	
	~Dragon()
	{
		cout << "dtor ->"<< endl;
		show();
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

// 객체의 생성과 소멸을 화면출력으로 관찰해보자


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:17:20 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) { cout << "생성" << endl; }
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();
	}
	
	~Dragon()
	{
		cout << "dtor ->";
		show();
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

// 객체의 생성과 소멸을 화면출력으로 관찰해보자


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:18:29 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default cotr ->";
		show();
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();
	}
	
	~Dragon()
	{
		cout << "dtor ->";
		show();
	}
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};

// 객체의 생성과 소멸을 화면출력으로 관찰해보자


int main()
{
	Dragon d1;
	Dragon d2("용가리", 3);

	d1.show();    //화면에 "이름 - 없음, 나이 -1살" 이라고 출력되도록 하자
	d2.show();    //화면에 "이름 - 용가리, 나이 3살" 이라고 출력되도록 하자

	
	save();
}








--------------------------------------------------
Mon Oct 16 13:45:07 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default cotr ->" << endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->" << endl;
		
	}
	int getAge() {
		return age;
	}
	~Dragon()
	{
		cout << "dtor" << endl;
		
	}
	
	void show()
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon);

void f(Dragon d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Mon Oct 16 13:54:52 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default cotr ->";
		show();//<< endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();// << endl;
		
	}
	int getAge() const{
		return age;
	}
	~Dragon()
	{
		cout << "dtor";
		show();// << endl;
		
	}
	
	void show() const
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon);

void f(Dragon d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Mon Oct 16 14:08:07 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default ctor ->";
		show();//<< endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();// << endl;
		
	}
	Dragon(const Dragon& other)
	{
		cout << "copy ctor ->";
		show();
	}
	int getAge() const{
		return age;
	}
	~Dragon()
	{
		cout << "dtor";
		show();// << endl;
		
	}
	
	void show() const
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon);

void f(Dragon d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Mon Oct 16 14:08:30 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default ctor ->";
		show();//<< endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();// << endl;
		
	}
	Dragon(const Dragon& )
	{
		cout << "copy ctor ->";
		show();
	}
	int getAge() const{
		return age;
	}
	~Dragon()
	{
		cout << "dtor";
		show();// << endl;
		
	}
	
	void show() const
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon);

void f(Dragon d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Mon Oct 16 14:10:26 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default ctor ->";
		show();//<< endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();// << endl;
		
	}
	Dragon(const Dragon& other) : name(other.name), age(other.age) 
	{
		cout << "copy ctor ->";
		show();
	}
	int getAge() const{
		return age;
	}
	~Dragon()
	{
		cout << "dtor";
		show();// << endl;
		
	}
	
	void show() const
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon);

void f(Dragon d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Mon Oct 16 14:14:33 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <fstream>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번



class Dragon{

	string name;
	int age;
public:
	Dragon() : name("없음"), age(-1) 
	{ 
		cout << "default ctor ->";
		show();//<< endl;
	}
	Dragon(string name, int age) : name(name), age(age){	
		cout << "ctor ->";
		show();// << endl;
		
	}
	Dragon(const Dragon& other) : name(other.name), age(other.age) 
	{
		cout << "copy ctor ->";
		show();
	}
	int getAge() const{
		return age;
	}
	~Dragon()
	{
		cout << "dtor";
		show();// << endl;
		
	}
	
	void show() const
	{
		cout << "이름 - " << name << "," << " 나이 " << age << "살" << endl;
	}
};



void f(Dragon&);

void f(Dragon& d)
{
	if (d.getAge() >= 10)
	{
		d.show();
	}
}

int main()
{
	Dragon dragons[5]{ {"용가리", 1}, {"레비아탄",3}, {"라에갈",11},{"비세리온",40}, {"드래곤", 7} };
	
	//함수 f는 Dragon을 인자로 받아, 나이가10살 이사인 용의 정보를 화면에 출력한다.
	//[질문] - 용의 나이를 어떻게 알면 좋은가?

	for (int i = 0; i < 5; ++i)
		f(dragons[i]);
	save();
}








--------------------------------------------------
Fri Oct 20 13:48:31 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog 
{
	string name= "없음";
	int age = -1;
public :
	Dog(string name, int age) : name(name), age(age) {
		
	}
	void bark()
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
};

int main()
{
	Dog a("멍맹이", 6);

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	save();
}








--------------------------------------------------
Fri Oct 20 13:55:41 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name= "없음";
	int age = -1;
public :
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
};

int main()
{
	Dog a("멍맹이", 6);

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	save();
}








--------------------------------------------------
Fri Oct 20 14:01:43 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name= "없음";
	int age = -1;
public :
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	Dog a("멍맹이", 6);

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	save();
}








--------------------------------------------------
Fri Oct 20 14:02:38 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name= "없음";
	int age = -1;
public :
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	{
	Dog a("멍맹이", 6);

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	}
	save();
}








--------------------------------------------------
Fri Oct 20 14:06:24 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:09:21 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;
	//쓰레기값 - 스택에 있는 메모리 할당시 그안에 있는 값이나옴 (지역변수)
	//0 -전역변수는 0으로 초기화됨

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:09:38 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;
	//쓰레기값 - 스택에 있는 메모리 할당시 그안에 있는 값이나옴 (지역변수)
	//0 -전역변수는 스택에 0으로 초기화됨

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:10:37 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "생성" << name << "," << age << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;
	//쓰레기값 - 스택에 있는 메모리 할당시 그안에 있는 값이나옴 (지역변수)
	//0 -전역변수는 스택에 0으로 초기화됨

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:10:46 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성" << name << "," << age << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성" << name << "," << age << endl;
	}
	~Dog() {
		cout << "소멸" << name << "," << age << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;
	//쓰레기값 - 스택에 있는 메모리 할당시 그안에 있는 값이나옴 (지역변수)
	//0 -전역변수는 스택에 0으로 초기화됨

	a.bark(); //화면에 "나이 6살인 멍맹이가 짖는다"라고 출력되도록 하라.
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:12:25 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
// 객체의 생성과 소멸을 관찰하라
int main()
{
	
	Dog a;
	Dog b = a;
	
	//쓰레기값 - 스택에 있는 메모리 할당시 그안에 있는 값이나옴 (지역변수)
	//0 -전역변수는 스택에 0으로 초기화됨

	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:16:52 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog&)
	{
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};

int main()
{
	
	Dog a;
	Dog b = a;
	


	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:17:46 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog&) : name(name) , age(age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};

int main()
{
	
	Dog a;
	Dog b = a;
	


	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:18:46 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};

int main()
{
	
	Dog a;
	Dog b = a;
	


	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:32:16 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
//객체가 복사되는 순간을 관찰
int main()
{
	
	Dog a;
	Dog b = a;
	


	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:45:42 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
//객체가 복사되는 순간을 관찰 -> 복사되면 복사생성자 함수를 컴파일러가 호출하는 코드를 말한다
int main()
{
	
	Dog a;
	Dog b ( a ); //b는 a를 복사하여 만든다
	


	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 14:47:38 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 모든 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		Sleep(1000);
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	
};
//객체가 복사되는 순간을 관찰 -> 복사되면 복사생성자 함수를 컴파일러가 호출하는 코드를 말한다
int main()
{
	
	Dog a;
	Dog b ( a ); //Dog b = a; b는 a를 복사하여 만든다
	
	b = a; //assignment

	b.bark(); 
	
	save();
}








--------------------------------------------------
Fri Oct 20 15:09:38 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 복사 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	//개의 나이를 설정

	void setAge(int num) {
		age = num;
	}
	int getAge() {
		return age;
	}
	void show(void) {
		cout << "나이 " << age << "살인 " << name << "개" << endl;
	}
};
void f(Dog );
void f(Dog a) {
	
	if (a.getAge() == 15) a.show();	
}
int main()
{
	//개 1000마리 동시에 움직이는 게임
	Dog dogs[1000]; //이름은 모두 "몰라", 나이는 -1인  1000마리의 개
	
	//개의 나이는 임의의 값으로 변경합니다(1~20 값으로)
	default_random_engine dre;
	uniform_int<> ui(1, 20);
	for (int i = 0; i < 1000; ++i){
		dogs[i].setAge(ui(dre));
	f(dogs[i]);
	}
    
	//과제 함수 f는 개의 나이가 15살이라면 화면에 그 개의 정보를 출력한다
	//필요한 멤버함수를 만들면서 해결해보자
	save();
}








--------------------------------------------------
Fri Oct 20 15:10:34 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//숙제 - C++ 책이나 구글에서 class 생성자와 소멸자 공부하기
// 
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//개가 주인공인 게임이다.
//개는 이름과 나이가 있다.
//개는 달릴(run) 수 있고 짖을(bark) 수 있다

//다음 main()이 잘 실행되도록  class를 잘만들어 보자.
//여기서 복사 생성자에는 호출될때마다 1초씩 쉬도록  Sleep(1000)을 호출하도록 하자.

class Dog {
	string name ;
	int age ;
public :
	Dog() : name("없음"), age(-1){
		cout << "기본생성 (" << name << "," << age << ")" << endl;
	}
	Dog(string name, int age) : name(name), age(age) {
		
		cout << "생성 (" << name << "," << age << ")" << endl;
	}
	Dog(const Dog& other) : name(other.name) , age(other.age){
		cout << "복사 생성자 (" << name << "," << age << ")" << endl;
	}
	~Dog() {
		cout << "소멸 (" << name << "," << age << ")" << endl;
	}
	void bark(void)
	{
		cout << "나이 " << age << "살인 " << name << "가 짖는다" << endl;
	}
	//개의 나이를 설정

	void setAge(int num) {
		age = num;
	}
	int getAge() {
		return age;
	}
	void show(void) {
		cout << "나이 " << age << "살인 " << name << "개" << endl;
	}
};
void f(Dog &);
void f(Dog &a) {
	
	if (a.getAge() == 15) a.show();	
}
int main()
{
	//개 1000마리 동시에 움직이는 게임
	Dog dogs[1000]; //이름은 모두 "몰라", 나이는 -1인  1000마리의 개
	
	//개의 나이는 임의의 값으로 변경합니다(1~20 값으로)
	default_random_engine dre;
	uniform_int<> ui(1, 20);
	for (int i = 0; i < 1000; ++i){
		dogs[i].setAge(ui(dre));
	f(dogs[i]);
	}
    
	//과제 함수 f는 개의 나이가 15살이라면 화면에 그 개의 정보를 출력한다
	//필요한 멤버함수를 만들면서 해결해보자
	save();
}








--------------------------------------------------
Mon Oct 23 12:44:59 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char a;
public:
	A() : a(0) {
		cout << "기본 생성" << endl;
	};
	A(char a) : a(a){
		cout << "생성" << endl;
	};
	~A() {
		cout << "소멸" << endl;
	};
	void show() 
	{
		cout << sizeof(a) << "바이트" << endl;
	}
};

int main()
{
	A a(100); //100바이트를 HEAP에서 할당

	a.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 12:54:10 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	
public:
	A() : p(0) {
		cout << "기본 생성" << endl;
	};
	A(int n) {
		 p = new char[n];
		cout << "생성" << endl;
	};
	~A() {
		cout << "소멸" << endl;
	};
	void show() 
	{
		cout << sizeof(p) << "바이트" << endl;
	}
};

int main()
{
	A a(100); //100바이트를 HEAP에서 할당

	a.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 12:59:11 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A() : num(0) {
		cout << "기본 생성" << endl;
	};
	A(int n) : num(n) {
		 p = new char[n];
		cout << "생성" << endl;
	};
	~A() {
		delete[] p;
		cout << "소멸" << endl;
	};
	void show() 
	{
		cout << sizeof(char(*p)) << "바이트" << endl;
	}
};

int main()
{
	A a(100); //100바이트를 HEAP에서 할당

	a.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:02:50 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A() : num(0) {
		cout << "기본 생성" << endl;
	};
	A(int n) : num(n) {
		 p = new char[n];
		cout << "생성" << endl;
	};
	~A() {
		delete[] p;
		cout << "소멸" << endl;
	};
	void show() 
	{
		cout << sizeof(*(char*)p) << "바이트" << endl;
	}
};

int main()
{
	A a(100); //100바이트를 HEAP에서 할당

	a.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:10:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*(char*)p)*num << "바이트" << endl;
	}
};

int main()
{
	A a[5] = { 1,10,100,1000,10000 }; //100바이트를 HEAP에서 할당
	for(int i=0; i<5; ++i)
	        a[i].show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:15:00 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	A a[5] = { 1,10,100,1000,10000 }; //100바이트를 HEAP에서 할당
	for(int i=0; i<5; ++i)
	        a[i].show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:20:18 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A& other) : num(other.num) {
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	A a(1234);  //100바이트를 HEAP에서 할당
	A b = a;
	b.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:26:35 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	A a(1234);  //100바이트를 HEAP에서 할당
	A b = a;
	b.show(); //"100바이트"라고 화면에 출력되도록 하자

	save();

}












--------------------------------------------------
Mon Oct 23 13:26:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	A a(1234);  //100바이트를 HEAP에서 할당
	A b = a;
	

	save();

}












--------------------------------------------------
Mon Oct 23 13:40:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	A a(1234);  //100바이트를 HEAP에서 할당
	A b = a;
	//복사 후 delete b 한다음 delete a 는 dangling 포인터가 되므로 컴퓨터가 죽는다.
	//해결책 -> 메모리를 다론 곳에 할당하여 깊은 복사를 한다.

	save();

}












--------------------------------------------------
Mon Oct 23 13:41:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	string a;
	cout << a << endl;
	save();

}












--------------------------------------------------
Mon Oct 23 13:42:10 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	string a;
	cout << sizeof(a) << endl;
	save();

}












--------------------------------------------------
Mon Oct 23 13:45:50 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰
class A {
	char* p;
	int num;
public:
	A(int n) : num(n) {
		 p = new char[n];
		cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) {
		num = c.num;
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
	}
	~A() {
		delete[] p;
		cout << num << "바이트를 해제" << endl;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};

int main()
{
	string a("312312312341323512325123518361283561283512352135215");
	string b = a;
	cout << b << endl;
	save();

}












--------------------------------------------------
Mon Oct 23 14:14:03 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(100, 1000);

class A {
	char* p;
	int num;
public:
	A()  {
		
		num = ui(dre);
		//cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) : num(c.num) {
		p = new char[num];
		//cout << num << "바이트를 복사" << endl;
		memcpy(p, c.p, num);
	}
	~A() {
		
		//cout << num << "바이트를 해제" << endl;
	}
	int getNum() {
		return num;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};
void f(A&);

void f(A& a) 
{
	
	if (a.getNum() == 717)
		a.show();
}

int main()
{
	//A 자료형의 객체를 1000개 만들어 봐라.
	//만들때 num을 (100~1000000까지의 수를 임의로 생성하여 사용하라)
    
	A a[1000];



	for (int i = 0; i < 1000; ++i)
		f(a[i]); //f 는 777바이트가 있다면 출력한다.
	
	save();

}












--------------------------------------------------
Mon Oct 23 14:14:40 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(100, 1000);

class A {
	char* p;
	int num;
public:
	A()  {
		
		num = ui(dre);
		//cout << num << "바이트를 할당" << endl;
	}
	A(const A&c) : num(c.num) {
		p = new char[num];
		cout << num << "바이트를 복사" << endl;
		memcpy(p, c.p, num);
	}
	~A() {
		
		//cout << num << "바이트를 해제" << endl;
	}
	int getNum() {
		return num;
	}
	void show() 
	{
		cout << sizeof(*p)*num << "바이트" << endl;
	}
};
void f(A&);

void f(A& a) 
{
	
	if (a.getNum() == 717)
		a.show();
}

int main()
{
	//A 자료형의 객체를 1000개 만들어 봐라.
	//만들때 num을 (100~1000000까지의 수를 임의로 생성하여 사용하라)
    
	A a[1000];



	for (int i = 0; i < 1000; ++i)
		f(a[i]); //f 는 777바이트가 있다면 출력한다.
	
	save();

}












--------------------------------------------------
Fri Oct 27 13:36:14 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(0, 100);



int main()
{
	dre.seed(2017182099);
	cout << ui(dre) << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 13:36:26 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(0, 100);



int main()
{
	dre.seed(2017182090);
	cout << ui(dre) << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 13:36:41 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(0, 100);



int main()
{
	dre.seed(2017182027);
	cout << ui(dre) << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 13:36:51 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(0, 100);



int main()
{
	dre.seed(2017182020);
	cout << ui(dre) << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 13:37:23 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;

//void exchange(char*& , char*&);  1번
//qsort(s,strlen(s),1,cmp[const void* a, const void* b]{
//return *(char *)a - *(char *) b ;
//}
//);    2번
//void(*x)(); auto x = f;       3번

//이 클래스는 생성 시에 양의 정수를 인자로 받아 그 만큼의 메모리를 HEAP에서 확보한다.
//main ()이 실행 되도록 프로그램해보자

//생성과 소멸 관찰

default_random_engine dre;
uniform_int_distribution<> ui(0, 100);



int main()
{
	dre.seed(2017182030);
	cout << ui(dre) << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 13:50:03 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;



//생성자(초기화자)는 왜 프로그램 하나?
//        -이미 만들어진 메모리를 초기화(RAII)하려고
class Dog {
	int age = 0xaaaaaaaa;
public:
	Dog() {};
	Dog(int a) : age(a) {}
	void show() { cout << age << endl; }
};

int main()
{
	Dog a;
	Dog b(333);
	a.show();
	b.show();
	save();

}












--------------------------------------------------
Fri Oct 27 13:56:43 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <Windows.h>
#include "save.h"
#include <random>
using namespace std;



//생성자(초기화자)는 왜 프로그램 하나?
//        -이미 만들어진 메모리를 초기화(RAII)하려고
//소멸자는 왜 프로그램 하나?
//        -사용된 메모리가 HEAP에 남아있기때문에 소멸
class Dog {
	int age = 0xaaaaaaaa;
public:
	Dog() {};
	Dog(int a) : age(a) {}
	void show() { cout << age << endl; }
};

int main()
{
	Dog a;
	Dog b(333);
	a.show();
	b.show();
	save();

}












--------------------------------------------------
Fri Oct 27 14:02:06 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	string str;
public:
	String() {};
	String(string s) : str(s) {}
	void show() { cout << str << endl; }
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:06:08 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	string str;
	char* p;
public:
	String() {};
	String(const char*s) : str(p) {
		p = new char[strlen(s)];
	}
	~String() {}
	void show() { cout << str << endl; }
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:15:54 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	int num;
	string str;
	char* p{ nullptr };
public:
	String() {};
	String(const char*s) : str(p)  {
		num = strlen(s);
		p = new char[num];
        memcpy(p, s, num); // 공부 필요
	}
	
	~String() { delete[] p; }
	void show() { cout << str << endl; }
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:16:27 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	int num;
	char* str;
	char* p{ nullptr };
public:
	String() {};
	String(const char*s) : str(p)  {
		num = strlen(s);
		p = new char[num];
        memcpy(p, s, num); // 공부 필요
	}
	
	~String() { delete[] p; }
	void show() { cout << str << endl; }
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:19:28 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	int num;
	char* p{ nullptr };
public:
	String() {};
	String(const char*s)  {
		num = strlen(s);
		p = new char[num];
        memcpy(p, s, num); // 공부 필요
	}
	
	~String() { delete[] p; }
	void show() 
	{ 
		char* temp = new char[num + 1];
		memcpy(temp, p, num);
		temp[num] = 0;

		cout << temp << endl;
		delete[]temp;
	}
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:36:13 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class String {
	int num;
	char* p{ nullptr };
public:
	String() {};
	String(const char*s)  {
		num = strlen(s);
		p = new char[num];
        memcpy(p, s, num); // 공부 필요
	}
	
	String(const String& b) {
		num = b.num;
		p = new char[num];
		memcpy(p, b.p, num);
	}
	~String() { 
		if(p==nullptr)
		delete[] p; 
	}
	void show() 
	{ 
		char* temp = new char[num + 1];
		memcpy(temp, p, num);
		temp[num] = 0;

		cout << temp << endl;
		delete[] temp;
	}
};

//class String 이다.
//생성시 const char*를 인자로 받아 이문자열을 HEAP에 저장한다
//main()이 실행되게 해보자

int main()
{
	String a("안녕 나는 String 클래스야");
	String b(a);

	a.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	b.show();  //화면에 "안녕 나는 String 클래스야"라고 출력

	save();

}












--------------------------------------------------
Fri Oct 27 14:52:22 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class Int {
	int value;
public:
	Int(int n) : value(n){}
	int getVal() const {return value;}
};

//정수값을 하나 저장하는 클래스 Int 이다.
//요구하는 프로그램을 

int main()
{
	Int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	// a를 정수값에 따라 오름차순으로 정렬하라(qsort를 사용해보자)
	qsort(a, 10, sizeof(Int), [](const void*p, const void*q) {
		return	((Int*)p)->getVal() - ((Int*)q)->getVal();
	});
	for (Int d : a)
		cout << d.getVal() << ""; // 1 2 3 4 5 6 7 8 9 10 출력
	cout << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 14:52:30 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class Int {
	int value;
public:
	Int(int n) : value(n){}
	int getVal() const {return value;}
};

//정수값을 하나 저장하는 클래스 Int 이다.
//요구하는 프로그램을 

int main()
{
	Int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	// a를 정수값에 따라 오름차순으로 정렬하라(qsort를 사용해보자)
	qsort(a, 10, sizeof(Int), [](const void*p, const void*q) {
		return	((Int*)p)->getVal() - ((Int*)q)->getVal();
	});
	for (Int d : a)
		cout << d.getVal() << " "; // 1 2 3 4 5 6 7 8 9 10 출력
	cout << endl;
	save();

}












--------------------------------------------------
Fri Oct 27 15:02:44 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class Dog {
	string name;
	int age;
public:
    Dog(string name, int age) : name(name), age(age) {}
	~Dog(){}
	int getAge() { return age; }
	void show() { cout << name << " , " << age << endl; }
};

int main()
{
	Dog dogs[5]{ {"1월",3},{ "2월",5 } ,{ "3월",1 } ,{ "4월",4} ,{ "5월",2 } };
	//qsort 이용 나이오름차순

	qsort(dogs, 5, sizeof(Dog), [](const void*p, const void*q) {
		return ((Dog*)p)->getAge() - ((Dog*)q)->getAge();
	});

	for (Dog d : dogs)
		d.show();
	save();

}












--------------------------------------------------
Fri Oct 27 15:12:22 2017
--------------------------------------------------

//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
#include <random>
using namespace std;

class Dog {
	string name;
	int age;
public:
    Dog(string name, int age) : name(name), age(age) {}
	~Dog(){}
	int getAge() const { return age; }
	void show() { cout << name << " , " << age << endl; }
};

int main()
{
	Dog dogs[5]{ {"1월",3},{ "2월",5 } ,{ "3월",1 } ,{ "4월",4} ,{ "5월",2 } };
	//qsort 이용 나이오름차순

	qsort(dogs, 5, sizeof(Dog), [](const void*p, const void*q) -> int {
		return ((Dog*)p)->getAge() - ((Dog*)q)->getAge();
	});

	for (Dog d : dogs)
		d.show();
	save();

}












--------------------------------------------------
Fri Nov  3 13:54:53 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uixy(-1000, 1000);
uniform_int_distribution<> uihp(1, 100);

class Dog {
	string id;
	int hp;
public:
	Dog() : id("unknown"), hp(-1){}
	void show() const {
		cout << "Dog : " << id << ", hp:" << hp << endl;
	}
};

int main()
{
	Dog a; // 지역 객체로 스택에 만들어짐 문자열은 힙에 만들어진다.
	Dog b = a; //컴퓨터가 기본 복사 생성자로 a와 b를 똑같이 복사해준다. b는 a와 다른 메모리에 만듬
	//포인터가 없음
	save();
}







--------------------------------------------------
Fri Nov  3 14:13:40 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uixy(-1000, 1000);
uniform_int_distribution<> uihp(1, 100);

class Dog {
	string id;
	int hp;
public:
	Dog() : id("unknown"), hp(-1){}
	void show() const {
		cout << "Dog : " << id << ", hp:" << hp << endl;
	}
};
Dog dogs[100000];
int main()
{
	
	// 스택을 늘린다 - 좋지 못한 해결책
	// 전역변수로 옮긴다 - 실행 파일의 크기 자체가 커진다. 메모리에 올라가는 크기가 커진다.
	save();
}







--------------------------------------------------
Fri Nov  3 14:16:57 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uixy(-1000, 1000);
uniform_int_distribution<> uihp(1, 100);

class Dog {
	string id;
	int hp;
public:
	Dog() : id("unknown"), hp(-1){}
	void show() const {
		cout << "Dog : " << id << ", hp:" << hp << endl;
	}
};
Dog dogs[100000];
int main()
{
	Dog* dogs = new Dog[100000];
	// 스택을 늘린다 - 좋지 못한 해결책
	// 전역변수로 옮긴다 - 실행 파일의 크기 자체가 커진다. 메모리에 올라가는 크기가 커진다.
	// 힙에서 메모리를 할당 받는다. (필요할때 메모리를 받고 돌려줄때)

	delete[] dogs;
	save();
}







--------------------------------------------------
Fri Nov  3 14:43:09 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


int main()
{
 //연산자란 무엇인가요? operator, + -	
 //단항연산자(unary) -a;
 //이항연산자(binary) a-b;
 
 //피연산자의 값을 연산자에서 지정한 동작을 거쳐 변경한다

	
	save();
}







--------------------------------------------------
Fri Nov  3 14:51:48 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


int main()
{
	cout.operator<<(777);
	//출력 연산자 << (이항 연산자)
	//연산자는 함수로 생각해보자 operator<< (cout, 777);
	
	save();
}







--------------------------------------------------
Fri Nov  3 14:58:50 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;


int main()
{
	cout << 123 << 456 << 789 << 333 << endl;
	(((cout.operator<<(123)).operator<<(456)).operator<<(789)).operator<<(333)<<endl;
	//너는 그냥 이렇게 써
	//그럼 컴파일러인 내가 이문장을 cout.operator<<(777) 이런함수호
	//자동 반환해 줄께
	save();
}







--------------------------------------------------
Fri Nov  3 15:18:48 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age){}
	string getName() const {
		return name;
    }
	int getAge() const {
		return age;
	}
   
};
 void operator<<(ostream& os, const Dog& s)
   {
	os << s.getName() << " , " << s.getAge() << "살";
	
   }
int main()
{
	//개를 출력 연산자를 이용해서 출력해 보자
	Dog a("순실이", 6);

	cout << a ; //화면에 "순실이, 6살"
	// 이 문장은 cout.operator<<(Dog)를 호출할 것이다.
	// 그럼 이 함수를 작성해 주면 끝이다. 
	//cout은 표준 객체이기때문에 프로그래머가 바꿀 수 없다
	//
	//이런 경우에 컴파일러는 다른 함수가 있는지 찾아본다
	// operator<<(ostream& cout ,const Dog&)를 찾아본다. 전역 함수이다
	save();
}







--------------------------------------------------
Fri Nov  3 15:19:00 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age){}
	string getName() const {
		return name;
    }
	int getAge() const {
		return age;
	}
   
};
 void operator<<(ostream& os, const Dog& s)
   {
	os << s.getName() << " , " << s.getAge() << "살" << endl;
	
   }
int main()
{
	//개를 출력 연산자를 이용해서 출력해 보자
	Dog a("순실이", 6);

	cout << a ; //화면에 "순실이, 6살"
	// 이 문장은 cout.operator<<(Dog)를 호출할 것이다.
	// 그럼 이 함수를 작성해 주면 끝이다. 
	//cout은 표준 객체이기때문에 프로그래머가 바꿀 수 없다
	//
	//이런 경우에 컴파일러는 다른 함수가 있는지 찾아본다
	// operator<<(ostream& cout ,const Dog&)를 찾아본다. 전역 함수이다
	save();
}







--------------------------------------------------
Mon Nov  6 13:02:03 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	void show()
	{
		cout << num << endl;
	}
};





int main()
{
	INT a(10), b(20); 
	INT c;

	//c = a + b;  //이것은 함수 호출 문장이다.
	            //INT operator+(INT, INT) 이런 함수를 찾아본다
	            //그런데 이 문장은
				//INT a.operator+(INT) 이렇게도 번역할 수 있는 문장이다.
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:06:56 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	void show()
	{
		cout << num << endl;
	}
	int operator+(INT& b) {
		return this->num + b.num;
	}
};





int main()
{
	INT a(10), b(20); 
	INT c;

	c = a + b; //프로그래머인나는
		   // 1: 이 문장은 a.operator+(INT)로 해석할 수 있으니까
		   //       class INT 안에 멤버함수 operator+를 만들어 해결한다
		   // 2: 이 문장은 INT operator(INT , INT)로 해석할 수 도 있으니까
		   //		전역함수를 만들어 해결한다
	c.show();
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:12:10 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	void show()
	{
		cout << num << endl;
	}
	INT operator+(INT& b) {
		return INT(num + b.num);
	}
};





int main()
{
	INT a(10), b(20); 
	INT c;

	c = a + b; //프로그래머인나는
		   // 1: 이 문장은 a.operator+(INT)로 해석할 수 있으니까
		   //       class INT 안에 멤버함수 operator+를 만들어 해결한다
		   // 2: 이 문장은 INT operator(INT , INT)로 해석할 수 도 있으니까
		   //		전역함수를 만들어 해결한다
	c.show();
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:22:56 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	int getNum() const { return num;}

	INT operator+(INT& b) {
      return num + b.num;
	}
};

INT operator+(int n, INT& i)
{
	return INT(n + i.getNum());
}



int main()
{
	INT a(11); 
	INT c;

	c = 100 + a; //프로그래머인나는
		   // 1: 이 문장은 a.operator+(INT)로 해석할 수 있으니까
		   //       class INT 안에 멤버함수 operator+를 만들어 해결한다
		   // 2: 이 문장은 INT operator(INT , INT)로 해석할 수 도 있으니까
		   //		전역함수를 만들어 해결한다
	cout << c.getNum() << endl;
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:23:26 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	int getNum() const { return num;}

	INT operator+(INT& b) {
      return num + b.num;
	}
};

INT operator+(int n, INT& i)
{
	return (INT)(n + i.getNum());
}



int main()
{
	INT a(11); 
	INT c;

	c = 100 + a; //프로그래머인나는
		   // 1: 이 문장은 a.operator+(INT)로 해석할 수 있으니까
		   //       class INT 안에 멤버함수 operator+를 만들어 해결한다
		   // 2: 이 문장은 INT operator(INT , INT)로 해석할 수 도 있으니까
		   //		전역함수를 만들어 해결한다
	cout << c.getNum() << endl;
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:35:29 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class INT {
	int num;
public:
	INT() : num(0){}
	INT(int n) : num(n) {}  
	int getNum() const { return num;}

	INT operator+(INT& b) {
      return num + b.num;
	}
};

INT operator+(int n, INT& i)
{
	return (INT)(n + i.getNum());
}



int main()
{
	INT a(11); 
	INT c;

	c = 100 + a; // 이 문장의 해석
				 // INT operator+(int, INT)
	cout << c.getNum() << endl;
	
	save();
}







--------------------------------------------------
Mon Nov  6 13:42:02 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	
};

bool operator<(Dog& a, Dog&b)
	{
		if (a.getAge() < b.getAge())
			return true;
		return false;
	}



int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	if (a < b)
		cout << a.getName() << "보다" << b.getName() << "가 나이가 더 많다" << endl;
	else
		cout << b.getName() << "보다" << a.getName() << "가 나이가 더 많다" << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 13:42:23 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	
};

bool operator<(Dog& a, Dog&b)
	{
		if (a.getAge() < b.getAge())
			return true;
		return false;
	}



int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	if (a < b)
		cout << a.getName() << "보다 " << b.getName() << "가 나이가 더 많다" << endl;
	else
		cout << b.getName() << "보다 " << a.getName() << "가 나이가 더 많다" << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 13:56:35 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	bool operator<(Dog&b)
	{
		
			
		return age < b.getAge();
	}
};





int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	if (a < b) // a.
		cout << a.getName() << "보다 " << b.getName() << "가 나이가 더 많다" << endl;
	else
		cout << b.getName() << "보다 " << a.getName() << "가 나이가 더 많다" << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 13:57:00 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	bool operator<(Dog&b)
	{
		
			
		return age < b.getAge();
	}
};





int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	if (a < b) // a.operator<(Dog) a의 멤버함수
		cout << a.getName() << "보다 " << b.getName() << "가 나이가 더 많다" << endl;
	else
		cout << b.getName() << "보다 " << a.getName() << "가 나이가 더 많다" << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 14:02:09 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	bool operator<(Dog&b) {return age < b.getAge();
	}
	
};

   ostream& operator<<(ostream& os, Dog& a)
	{
		return os << a.getName() << " , " << a.getAge();
	}



int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	cout << "둘 중 나이가 많은 개는";
	if (a < b) // a.operator<(Dog) a의 멤버함수
		cout << b << endl;
	else
		cout << a << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 14:02:20 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	bool operator<(Dog&b) {return age < b.getAge();
	}
	
};

   ostream& operator<<(ostream& os, Dog& a)
	{
		return os << a.getName() << " , " << a.getAge();
	}



int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	cout << "둘 중 나이가 많은 개는 ";
	if (a < b) // a.operator<(Dog) a의 멤버함수
		cout << b << endl;
	else
		cout << a << endl;
	save();
}







--------------------------------------------------
Mon Nov  6 14:14:11 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
	string name;
	int age;
public:
	Dog(string name, int age) : name(name), age(age) {}
	int getAge() const { return age;  }
	string getName() const { return name; }
	bool operator<(Dog&b) {return age < b.getAge();}

	friend ostream& operator<<(ostream& os, const Dog& a); //입출력의 용도로만 쓰는것이다 ostream쓸때
	
};

   ostream& operator<<(ostream& os, const Dog& a)
	{
		return os << a.getName() << " , " << a.getAge();
	}



int main()
{
	Dog a("순실이", 6), b("바둑이", 10);

	cout << "둘 중 나이가 많은 개는 ";
	if (a < b)
		cout << b << endl;
	else
		cout << a << endl;
	ofstream out("개판.txt");
	out << a << endl;
	out << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 13:38:37 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	Int(int n) : num(n) {}
	Int operator+(Int& b)
	{
		return Int(num + b.num);
	}
	int getNum() {
		return num;
	}
};
ostream& operator<<(ostream& os, Int& a)
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10), b(20);
	Int c;
	c = a + b;
	cout << c << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:01:43 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int operator++() {
		++num;
		return *this;
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = ++a;
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:02:10 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int operator++() {
		++num;
		return *this;
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = ++++++++++++a;
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:03:46 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int& operator++() {
		++num;
		return *this;
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = ++ ++ ++ ++ a;
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:04:00 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int operator++() {
		++num;
		return *this;
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = ++ ++ ++ ++ a;
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:09:32 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int& operator++() { //전위 증가
		++num;
		return *this;
	}
	Int operator++(int)  //전위 증가와 오버로딩되므로 int를 써줘야한다.
	{
		Int t(*this); //나의 복사본을 만든다
		++num;//나 자신을 1증가 ++(*this)num; 정석임
		return t;//복사본 값을 리턴 , 스택(지역변수)이므로 레퍼런스를 붙일 수 없다.
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = a ++; // a.operator++()
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:09:49 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int& operator++() { //전위 증가
		++num;
		return *this;
	}
	Int operator++(int)  //전위 증가와 오버로딩되므로 int를 써줘야한다.
	{
		Int t(*this); //나의 복사본을 만든다
		++num;//나 자신을 1증가 ++(*this)num; 정석임
		return t;//복사본 값을 리턴 , 스택(지역변수)이므로 레퍼런스를 붙일 수 없다.
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   



int main()
{
	Int a(10);
	Int b;
	b = a ++ ++ ++ ++; // a.operator++()
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:33:17 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Int {
	int num;
public:
	Int() : num(0) {}
	explicit Int(int n) : num(n) {} //explicit 강제 형변환을 막는다.
	int getNum() const {return num;}
	Int operator+(const Int& b) //원래 전역에서 정의 해줘야한다. const 붙이는 것 잊지 말자
	{
		return Int(num + b.num); //리턴 값은 항상 함수 형과 같게하라
	}
	
	Int& operator++() { //전위 증가
		++num;
		return *this;
	}
	Int operator++(int)  //후위 증가 , 전위 증가와 오버로딩되므로 int를 써줘야한다.
	{
		Int t(*this); //나의 복사본을 만든다
		++num;//나 자신을 1증가 ++(*this)num; 정석임
		return t;//복사본 값을 리턴 , 스택(지역변수)이므로 레퍼런스를 붙일 수 없다.
	}
};
ostream& operator<<(ostream& os, const Int& a) //ostream(cout) 앞에 const를 붙이면 안된다 계속 변하는 객체이기 때문에
{
	return os << a.getNum();
}
   


//for loop문을 쓸때 i++을 쓰게되면 operator++의 후위증가가 더 복잡한것처럼
//쓸데없는 복사가 일어나므로 전위증가(++i)를 쓰는게 낫다.

int main()
{
	Int a(10);
	Int b;
	b = a ++; // a.operator++()
	cout << a << " , " << b << endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:35:31 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class Dog {
};

int main()
{
	string a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는" << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	string b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Fri Nov 10 14:59:33 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class ctring {
	int num;
	char* p;
public:
	ctring(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}
	ctring(const ctring& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}
	int length() const {return num;}
	
	ctring operator+(const char* t) {
		return ctring(strcat(p, t));
	}
	friend ostream& operator<<(ostream& os, const ctring& other) {
		os << other.p;
		return os;
	}

};



int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Fri Nov 10 15:13:54 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class ctring {
	int num;
	char* p;
public:
	ctring(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}
	ctring(const ctring& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}
	int length() const {return num;}
	
	ctring& operator+(const char* s) {
		 //내가 이미 만들어져 있는데 더 큰 글자를 저장해야 한다
	     //내가 확보한 메모리 보다 더큰 메모리를 새로 잡는다
		int nbyte = num + strlen(s);//얼마잡을지 계산한다
		char* tp = new char[nbyte];
		//새로잡은 메모리에 내원래데이터를 복사한다.
		memcpy(tp, p, num);
		delete[] p;//내 이전 메모리를 해제한다
		p = tp;// 새로 잡은 메모리의 주소를 저장한다
		
		memcpy(p + num,s,strlen(s));
		num = nbyte; //글자 수도 갱신한다
		//새로잡은 메모리에 전달된 문장을 덧 붙인다
		return *this;

	}
	~ctring() { delete[] p; }
	friend ostream& operator<<(ostream& os, const ctring& other) {
		os << other.p;
		return os;
	}

};



int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Fri Nov 10 17:23:51 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class ctring {
	int num;
	char* p;
public:
	ctring(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}
	ctring(const ctring& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}
	int length() const {return num;}

	ctring& operator+(const char* s) {
		 //내가 이미 만들어져 있는데 더 큰 글자를 저장해야 한다
	     //내가 확보한 메모리 보다 더큰 메모리를 새로 잡는다
		int nbyte = num + strlen(s);//얼마잡을지 계산한다
		char* tp = new char[nbyte];
		//새로잡은 메모리에 내원래데이터를 복사한다.
		memcpy(tp, p, num);
		delete[] p;//내 이전 메모리를 해제한다
		p = tp;// 새로 잡은 메모리의 주소를 저장한다
		
		memcpy(p + num,s,strlen(s));
		num = nbyte; //글자 수도 갱신한다
		//새로잡은 메모리에 전달된 문장을 덧 붙인다
		
		return *this;

	}
	~ctring() { delete[] p; }
	friend ostream& operator<<(ostream&os, const ctring& c);

};

 ostream& operator<<(ostream&os, const ctring& c)
{
	for (int i = 0; i < c.num; ++i)
		os << c.p[i];
	return os;
}

int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 12:31:32 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//앞으로 - 클래스 연산자 오버로딩
//진짜 클래스 만들어보기 -string ,array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
//정수를 멤버변수로 갖는 클래스 인트
//이 클래스는 인트(int n)에서 n의 값을 멤버변수 num저장한다
//main()이 실행되게 해 보자
class ctring {
	int num;
	char* p;
public:
	ctring(const char* str) {
		num = strlen(str);
		p = new char[num];
		memcpy(p, str, num);
	}
	ctring(const ctring& other) {
		num = other.num;
		p = new char[num];
		memcpy(p, other.p, num);
	}
	int length() const {return num;}

	ctring& operator+(const char* s) {
		 //내가 이미 만들어져 있는데 더 큰 글자를 저장해야 한다
	     //내가 확보한 메모리 보다 더큰 메모리를 새로 잡는다
		int nbyte = num + strlen(s);//얼마잡을지 계산한다
		char* tp = new char[nbyte];
		//새로잡은 메모리에 내원래데이터를 복사한다.
		memcpy(tp, p, num);
		delete[] p;//내 이전 메모리를 해제한다
		p = tp;// 새로 잡은 메모리의 주소를 저장한다
		
		memcpy(p + num,s,strlen(s));
		num = nbyte; //글자 수도 갱신한다
		//새로잡은 메모리에 전달된 문장을 덧 붙인다
		
		return *this;

	}
	~ctring() { delete[] p; }
	friend ostream& operator<<(ostream&os, const ctring& c);

};

 ostream& operator<<(ostream&os, const ctring& c)
{
	for (int i = 0; i < c.num; ++i)
		os << c.p[i];
	return os;
}

int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!12312312";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 12:51:35 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	//ctring b = a;
	//cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 12:52:56 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	//ctring b = a;
	//cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 12:54:31 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	//ctring b = a;
	//cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 12:57:17 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	//ctring b = a;
	//cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:05:13 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:05:18 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:07:41 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+=(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a  += "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:12:29 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	ctring operator=(const ctring& o)
	{
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:12:38 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	ctring& operator=(const ctring& o)
	{
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:15:28 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	ctring& operator=(const ctring& o)
	{
		delete[] p;
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:17:09 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:18:28 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:22:25 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num;
		p = new char[num+1];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:22:36 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:23:29 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		cout << o.p << endl;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:24:12 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		cout << o.p << endl;
		system("pause");
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	//ctring c("난 c야!");
	//c = a;
	//cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:24:26 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		cout << o.p << endl;
		system("pause");
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	//ctring c("난 c야!");
	//c = a;
	//cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:29:16 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	/*ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}*/
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";
	cout << a << endl;
	ctring b = a;
	cout << b <<endl;

	//ctring c("난 c야!");
	//c = a;
	//cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:32:14 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";


	//ctring c("난 c야!");
	//c = a;
	//cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:32:32 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	cout << "내가 저장하고 있는 글자 수는 " << a.length() << endl;
	a = a + "!!!";


	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:33:28 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	ctring a{ "안녕, 꼭 알아야 할 클래스 string 이야" };
	
	a = a + "!!!";


	ctring c("난 c야!");
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:36:11 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	string a(" C++ standard move emantic");
	string b = a;
	string c("그냥 만듬");
	c = a;
	save();
}







--------------------------------------------------
Mon Nov 13 13:36:50 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	string a(" C++ standard move emantic");
	cout << a << endl;
	string b = a;
	cout << b << endl;
	string c("그냥 만듬");

	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:38:11 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	string a(" C++ standard move emantic");
	
	string b = a;
	
	string c("그냥 만듬");
	b = move(a);
	cout << b << endl;
	cout << a << endl;
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:39:26 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() { 
		if(p!=nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num+1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}
	
	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c. num] = '\0';
	os << t;
	delete[] t;
	return os;
}


int main()
{
	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	ctring a(" C++ standard move emantic");
	
	ctring b = a;
	
	ctring c("그냥 만듬");
	//b = move(a);  //static_cast<string&&>(a); 원래 표기는 이렇게함
	cout << b << endl;
	cout << a << endl;
	c = a;
	cout << c << endl;
	save();
}







--------------------------------------------------
Mon Nov 13 13:52:09 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	~ctring() {
		if (p != nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num + 1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}

	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c.num] = '\0';
	os << t;
	delete[] t;
	return os;
}
int main()
{
	


	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	ctring a(" C++ standard move emantic");
	ctring b = a;
	b = static_cast<ctring&&>(a);  //static_cast<string&&>(a); 원래 표기는 이렇게함
	cout << b << endl;
	cout << a << endl;
	
	save();

	
}







--------------------------------------------------
Mon Nov 13 13:55:55 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	//이동 생성자
	ctring(ctring&& other) {
		p = other.p;
		num = other.num;
		other.p = nullptr;
		other.num = 0;
	}
	~ctring() {
		if (p != nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num + 1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}

	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c.num] = '\0';
	os << t;
	delete[] t;
	return os;
}
int main()
{
	


	//지금 연습하는 클래스는 c++ 표준 string입니다.
	//이름만 string -> ctring 으로 바꿔 본 겁니다.
	ctring a(" C++ standard move emantic");
	ctring b = static_cast<ctring&&>(a);  // b는 a를 이동하여 생성
	cout << b << endl;
	cout << a << endl;
	
	save();

	
}







--------------------------------------------------
Mon Nov 13 14:01:55 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class ctring {
	char* p{ nullptr };
	int num = 0;
public:
	ctring(char* s) {
		num = strlen(s);
		p = new char[num];
		memcpy(p, s, num);
	}
	ctring(const ctring& o) {
		num = o.num;
		p = new char[num];
		memcpy(p, o.p, num);
	}
	//이동 생성자
	ctring (ctring&& other) {
		p = other.p;
		num = other.num;
		other.p = nullptr;
		other.num = 0;
	}
	~ctring() {
		if (p != nullptr)
			delete[] p;
	}
	ctring& operator=(const ctring& o)
	{
		if (p != nullptr) delete[] p;
		num = o.num + 1;
		p = new char[num];
		memcpy(p, o.p, num);
		return *this;
	}
	ctring& operator=(ctring&& other) {
		p = other.p;
		num = other.num;
		other.p = nullptr;
		other.num = 0;
		return *this;
	}
	int length() const { return num; }
	ctring& operator+(const char* o) {
		char *tp;
		int nbyte;
		nbyte = num + strlen(o);
		tp = new char[nbyte];
		memcpy(tp, p, num);
		memcpy(tp + num, o, strlen(o));
		if (p != nullptr)
			delete[] p;
		p = tp;
		num = nbyte;
		return *this;
	}

	friend ostream& operator<<(ostream& os, ctring& c);
};

ostream& operator<<(ostream& os, ctring& c)
{
	char* t = new char[c.num + 1];
	memcpy(t, c.p, c.num);
	t[c.num] = '\0';
	os << t;
	delete[] t;
	return os;
}
int main()
{

	ctring a(" C++ standard move emantic");
	ctring b("1");
	b= move(a);
	
	cout << b << endl;
	cout << a << endl;
	
	save();

	
}







--------------------------------------------------
Mon Nov 13 14:20:48 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;


//class
//- 사용자가 원하는 만큼 메모리를 확보하낟.
//- 멤버변수와 멤버함수를 사용할 수 있다.
//
// 언제/왜/ 생성자와 소멸자를 프로그램해야 하는가
// 
// 생성자 - 객체의 메모리가 만들어진 후 호출되는 함수이다
//		메모리의 내용을 특정한 값으로 채우려면 이 함수에서 프로그램한다
//		객체에서 필요한 자원을 할당하는 경우 여기서 프로그램한다.
//		- 이런 일이 필요하지 않다면 생성자를 프로그램할 이유는 없다.
//
// 소멸자 - 객체의 메모리가 사라지기 직전에 호출되는 함수이다.
//		생성자에서 자원을 할당한 경우에만 프로그램할 이유가 있다.
//		생성자에서 확보한 자원을 되돌려주는 용도로 사용한다.
//		- 이런 일이 필요하지 않다면 생성자를 프로그램할 이유는 없다.
//
// 당신이 프로그래머이고 C++ 클래스를 설계한다면
// 그리고 또 객체를 만들때 자원(메모리, 파일, 애니메이션 데이터, 텍스쳐, 프린터)을
// 그 객체가 생성될 때 자원도 생성하였다면,
// 즉 생성자에서 동적으로 자원을 할당했다면
//
// 그러면 꼭 꼭 ----->
//
// 1.소멸자를 프로그램하여 할당한 자원을 되돌려 줘야 한다.
// 2.객체가 복사될때 깊은 복사가 되도록 복사생성자를 프로그램하여
//   댕글링 포인터가 생기지 않도록 해야한다.
// 3.copy assignment operator(=)를 프로그램하여
//   이미 생성된 객체가 다른 객체로 할당될 때 댕글링 포인터가 생기지 않도록 해야 한다.
//
// C++11의 이동 의미론을 이용하려면
// 4. 이동생성자를 프로그램하여야 한다.
// 5. move assignment operator(=)를 프로그램하여
//    이미 생성된 객체가 다른 객체로 이동 할당될 때 깊은 복사가 일어나지 않도록 하면
//    매우 효울적인 프로그램이 될 수 있다.
//
// --> 이 모든 것은 생성자에서 자원을 할당하지 않는다면 아무 필요가 없다.

int main()
{


	save();

	
}







--------------------------------------------------
Mon Nov 27 13:04:29 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//진짜 클래스 만들어보기 array
//클래스 간의 관계 상속
//클래스 실습
//
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


class Animal {
public:
	virtual void speak() const = 0;

};

class Dog : public Animal {
public:
	virtual void speak() const override {
		cout << "멍멍" << endl;
	}
};

class Bird : public Animal {
public:
	virtual void speak() const override {
		cout << "짹짹" << endl;

	}
};
class Bat : public Animal {
public:
	virtual void speak() const override {
		cout << "찍찍" << endl;
	}
};
class Cat : public Animal {
public:
	virtual void speak() const override {
		cout << "야옹" << endl;

	}
};

int main()
{


	cout << " hi animal farm" << endl;
	cout << " How much make?";
	int num;
	cin >> num;

	default_random_engine dre;
	uniform_int_distribution<> uid(1,4);

	Animal** p = new Animal*[num];

	for (int i = 0; i < num; ++i){
		switch (uid(dre))
		{
		case 1:
			p[i] = new Dog;
			break;
		case 2:
			p[i] = new Cat;
			break;
		case 3:
			p[i] = new Bird;
			break;
		case 4:
			p[i] = new Bat;
		}
	}
	while(true){
	for (int i = 0; i < num; ++i)
		p[i]->speak();
	char c;
	cin >> c;
	if (c == 'z' || c == 'Z')
		break;
	}
	for (int i = 0; i < num; ++i) {
		delete p[i];
	}
	delete[] p;
	save();


}






--------------------------------------------------
Mon Nov 27 13:26:01 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) {}
};

class Dog : public Animal{
public:
	Dog(string s, int a) : Animal(s, a) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
};
class Bird : public Animal{};
int main()
{

	Dog d("멍뭉이", 3);
	
	save();


}






--------------------------------------------------
Mon Nov 27 13:35:51 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
};

class Dog : public Animal{
public:
	Dog(string s, int a) : Animal(s, a) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
};
class Bird : public Animal{};
int main()
{

	Dog d("멍뭉이", 3);
	
	save();


}






--------------------------------------------------
Mon Nov 27 13:46:45 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
};
class Bird : public Animal{};
int main()
{

	Dog d("멍뭉이", 3,"포메라니안");
	cout << sizeof(Animal) << endl;
	if (sizeof(Animal) + sizeof(string) == sizeof(Dog))
		cout << "생각한대로 메모리크기는 조상+내꺼" << endl;
	
	save();


}






--------------------------------------------------
Mon Nov 27 13:52:20 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	void speak() {
		cout << name << ", " << age << "가(이) speak" << endl;
	}
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
};
class Bird : public Animal{};
int main()
{

	Dog d("응",3, "ㅇ");
	
	save();


}






--------------------------------------------------
Mon Nov 27 13:52:40 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	void speak() {
		cout << name << ", " << age << "가(이) speak" << endl;
	}
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
};
class Bird : public Animal{};
int main()
{

	Dog d("응",3, "ㅇ");
	d.speak();
	save();


}






--------------------------------------------------
Mon Nov 27 13:58:12 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	void speak() {
		cout << name << " - " << age << " - ";
	}
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
	void speak() {
		Animal::speak();
		cout << kind << "이 짖는다" << endl;
	}
};
class Bird : public Animal{};

//virtual keyword는 무슨역할을 하는가?
int main()
{

	Dog d("응",3, "ㅇ");
	d.speak(); //응  - 3 - ㅇ이 짖는다
	save();


}






--------------------------------------------------
Mon Nov 27 13:58:37 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	void speak() {
		cout << name << " - " << age << " - ";
	}
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
	void speak() {
		Animal::speak();
		cout << kind << "이 짖는다" << endl;
	}
};
class Bird : public Animal{};

//virtual keyword는 무슨역할을 하는가?
int main()
{

	Dog d("순실이",6, "시바");
	d.speak(); 
	save();


}






--------------------------------------------------
Mon Nov 27 13:58:53 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	void speak() {
		cout << name << " - " << age << " - ";
	}
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
	void speak() {
		Animal::speak();
		cout << kind << "가 짖는다" << endl;
	}
};
class Bird : public Animal{};

//virtual keyword는 무슨역할을 하는가?
int main()
{

	Dog d("순실이",6, "시바");
	d.speak(); 
	save();


}






--------------------------------------------------
Mon Nov 27 14:09:05 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
protected:
	string name;
	int age;
public:
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	/*void speak() {
		cout << name << " - " << age << " - ";
	}*/
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
	void speak() {
		cout << name << " - " << age << " - ";
		cout << kind << "가 짖는다" << endl;
	}
};
class Bird : public Animal{};

//virtual keyword는 무슨역할을 하는가?
int main()
{

	Dog d("순실이",6, "시바");
	d.speak(); 
	save();


}






--------------------------------------------------
Mon Nov 27 14:17:40 2017
--------------------------------------------------


//-------------------------------------------------------------------------------------------------------
//2017.2 C++               월45금56	                    9.4 월요일                  9.1금요일 (4주 1)
//
//퀴즈 - 9.29 금요일 - 강의한 내용 9.22일자까지
//
//9.2 - 한 학기 강의를 저장할 수 있도록 save()를 만듦.
//9.4 - file 분리,
//    - CPP I/O, cin, cout
//    - 두 변수값의 교환 , pointer
//9.8 - 참조(reference)
//    - namespace, 선언, 메모리 , auto , decltype
//
//9.11 - qsort, 정렬이란 무엇인가? 찾아서 읽어보자.
//       const - ROM
//       void* - 이 번지의 내용은 알아서 타입변환해라
//
//9.15 - 메모리 구조, 동적할당
//9.18 - new,delete
//       자원할당과 smart pointer
//       range based for loop
//9.22 - 함수 ->callable type, overloading, lambda
//9.25 - 클래스
//      클래스는 사용자가 원하는 만큼의 메모리를 확보하는 것이 기본동작이다
//      메모리의 크기를 확인하고
//      메모리 내용에 access하고
//      메모리를 초기화하고
//      다 쓴 메모리를 clear하는 방법 등을 알아본다
//
//9.29 - 다른 클래스를 만드며 복습하기
//
//10.13 - 퀴즈 확인
//        다른 클래스를 만들며 복습
//
//10.20 - 반복
//
//10.23 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?
//
//10.27 - 도대체 왜 생성자/소멸자/복사생성자를 프로그램해야 되지?     
//
//11.03 중간고사 확인
//      operator overloading
//11.10 - 클래스 연산자 오버로딩
//11.13 - ctring class
//11.17 - 클래스 만들어보기 array
//
//상속을 하는 이유 - 다형성(Polymorphism)을 구현하려고
//
//클래스 간의 관계 상속
//클래스 실습
//
//상속(inheritance) - 장점과 단점
//		  자식은 부모 클래스의 변수와 함수를 상속받는다.
//		  부모의 메모리 크기 <= 자식의 메모리 크기
//계층도(hierarchy) - 부모 자식 클래스 간의 관계를 화살표로 표시
//					  반드시 자식에서 부모쪽으로 화살표 방향을 표시한다.
//상속을 하는 이유 중 중요하고 꼭 공부해야 할 내용 - 다형성을 구현하는 내용
//
//*앞에 붙은 자료형은 어떤 뜻인가?
//		-> 포인터의 연산에서 이동해야 할 메모리의 크기를 결정하는 것뿐
//
//상속
// 생성과 소멸의 순서
// 메모리 크기(virtual 키워드 추가시 일어나는 일)
// 가상 소멸자를 작성하여야 하는 이유
// 다형성을 구현하기 위한 다른 방법
// 새로운 qualifier들 (override, final)
//
//12.18 월(15주 1) - 기말고사
//-------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//Animal(이름,나이)
//Dog bird
//
//이렇게 클래스를 프로그램하려고 한다.
//

//메인이 실행되도록 하는데 생성자와 소멸자에서 관찰메시지를 출력해보자
class Animal {
protected:
	string name;
	int age;
public:
	Animal(){
		cout << "Animal의 default 생성" << endl;
	}
	Animal(string s, int a) : name(s), age(a) { cout << "동물생성" << endl; }
	~Animal() { cout << "동물 소멸" << endl; }
	// class 동물에 speak()라는 함수가 있다는 것은
	//모든 동물이 speak해야 함을 의마한다.
	//speak() 하지 않으면 animal이 아니라는 것이다.
	//virtual이 붙은 함수는 자식 클래스에서 이 함수를 오버로딩하여야 함을 의미한다.
	virtual void speak() {};
		//cout << name << " - " << age << " - ";
	
};

class Dog : public Animal{
	string kind;
public:
	Dog(string s, int a, string k) : Animal(s, a) ,kind(k) { cout << "개 생성" << endl; }
	~Dog() { cout << "개 소멸" << endl; }
	void speak() {
		cout << name << " - " << age << " - ";
		cout << kind << "가 짖는다" << endl;
	}
};
class Bird : public Animal{
public:
	Bird() {
		cout << "Bird의 default 생성" << endl;
}

};

//virtual keyword는 무슨역할을 하는가?
int main()
{

	Dog d("순실이",6, "시바");
	d.speak(); 
	Bird b;
	save();


}




